/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 38
(module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.plintus-properties-panel {
    width: 300px;
    height: 100%;
    background: #fff;
    border-left: 1px solid #ddd;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    flex-shrink: 0; /* Prevent panel from shrinking */
}

.panel-header {
    padding: 15px;
    border-bottom: 1px solid #ddd;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.panel-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
}

.delete-button {
    padding: 6px 12px;
    background: #dc3545;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.delete-button:hover {
    background: #c82333;
}

.panel-content {
    padding: 15px;
    flex: 1;
}

.properties-elements-list {
    margin-bottom: 20px;
}

.properties-elements-list h4 {
    margin: 0 0 10px 0;
    font-size: 14px;
    font-weight: 600;
    color: #555;
}

.properties-elements-list-items {
    list-style: none;
    padding: 0;
    margin: 0;
}

.properties-element-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    margin-bottom: 4px;
    background: #f5f5f5;
    border-radius: 4px;
    font-size: 13px;
}

.element-type-badge {
    background: #0073aa;
    color: #fff;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
}

.element-id {
    color: #666;
    font-weight: 500;
}

.element-length {
    margin-left: auto;
    color: #333;
    font-weight: 600;
}

.arc-properties,
.line-properties,
.fillet-properties {
    margin-top: 20px;
    padding: 15px;
    background: #f9f9f9;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
}

.arc-properties h4,
.line-properties h4,
.fillet-properties h4 {
    margin: 0 0 15px 0;
    font-size: 14px;
    font-weight: 600;
    color: #333;
}

.property-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding: 8px 0;
    border-bottom: 1px solid #e0e0e0;
}

.property-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.property-item label {
    font-size: 13px;
    color: #666;
    font-weight: 500;
}

.property-value {
    font-size: 13px;
    color: #333;
    font-weight: 600;
}

.property-input {
    width: 80px;
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 13px;
    text-align: right;
}

.property-input:focus {
    outline: none;
    border-color: #0073aa;
    box-shadow: 0 0 0 2px rgba(0, 115, 170, 0.1);
}

.properties-empty-state {
    color: #999;
    font-size: 13px;
    font-style: italic;
    margin: 10px 0;
    padding: 10px;
    text-align: center;
}

.properties-summary {
    margin-bottom: 20px;
    padding: 15px;
    background: #f9f9f9;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
}

.properties-summary h4 {
    margin: 0 0 15px 0;
    font-size: 14px;
    font-weight: 600;
    color: #333;
}

.properties-section {
    margin-top: 20px;
    margin-bottom: 15px;
}

.properties-section-title {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: #333;
}

.summary-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding: 8px 0;
    border-bottom: 1px solid #e0e0e0;
}

.summary-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.summary-label {
    font-size: 13px;
    color: #666;
    font-weight: 500;
}

.summary-value {
    font-size: 13px;
    color: #333;
    font-weight: 600;
}




`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ 47
(module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.plintus-vertical-toolbar {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    padding: 10px;
    background: #fff;
    border-right: 1px solid #ddd;
    width: 120px;
    gap: 5px;
}

.plintus-vertical-tool-button {
    width: 100%;
    min-height: 50px;
    border: 1px solid #ddd;
    background: #fff;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px 5px;
    margin: 0;
    transition: all 0.2s;
    gap: 4px;
}

.plintus-vertical-tool-button:hover {
    background: #f0f0f0;
    border-color: #0073aa;
}

.plintus-vertical-tool-button.active {
    background: #0073aa;
    color: #fff;
    border-color: #0073aa;
}

.plintus-vertical-tool-button-text {
    font-size: 12px;
    line-height: 1.2;
    text-align: center;
    white-space: nowrap;
}

.plintus-vertical-tool-button i {
    font-size: 24px;
}



`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ 52
(module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.canvas-editor {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
}

#plintus-paperjs-canvas {
    display: block;
    width: 100%;
    height: 100%;
    /* Размеры устанавливаются через атрибуты width и height, не через CSS */
}

`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ 56
(module, __unused_webpack_exports, __webpack_require__) {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ },

/***/ 72
(module) {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ },

/***/ 113
(module) {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ },

/***/ 162
(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(594),
  shim = __webpack_require__(888);
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is,
  useSyncExternalStore = shim.useSyncExternalStore,
  useRef = React.useRef,
  useEffect = React.useEffect,
  useMemo = React.useMemo,
  useDebugValue = React.useDebugValue;
exports.useSyncExternalStoreWithSelector = function (
  subscribe,
  getSnapshot,
  getServerSnapshot,
  selector,
  isEqual
) {
  var instRef = useRef(null);
  if (null === instRef.current) {
    var inst = { hasValue: !1, value: null };
    instRef.current = inst;
  } else inst = instRef.current;
  instRef = useMemo(
    function () {
      function memoizedSelector(nextSnapshot) {
        if (!hasMemo) {
          hasMemo = !0;
          memoizedSnapshot = nextSnapshot;
          nextSnapshot = selector(nextSnapshot);
          if (void 0 !== isEqual && inst.hasValue) {
            var currentSelection = inst.value;
            if (isEqual(currentSelection, nextSnapshot))
              return (memoizedSelection = currentSelection);
          }
          return (memoizedSelection = nextSnapshot);
        }
        currentSelection = memoizedSelection;
        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
        var nextSelection = selector(nextSnapshot);
        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
          return (memoizedSnapshot = nextSnapshot), currentSelection;
        memoizedSnapshot = nextSnapshot;
        return (memoizedSelection = nextSelection);
      }
      var hasMemo = !1,
        memoizedSnapshot,
        memoizedSelection,
        maybeGetServerSnapshot =
          void 0 === getServerSnapshot ? null : getServerSnapshot;
      return [
        function () {
          return memoizedSelector(getSnapshot());
        },
        null === maybeGetServerSnapshot
          ? void 0
          : function () {
              return memoizedSelector(maybeGetServerSnapshot());
            }
      ];
    },
    [getSnapshot, getServerSnapshot, selector, isEqual]
  );
  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
  useEffect(
    function () {
      inst.hasValue = !0;
      inst.value = value;
    },
    [value]
  );
  useDebugValue(value);
  return value;
};


/***/ },

/***/ 206
(module) {

module.exports = ReactDOM;

/***/ },

/***/ 242
(module, __unused_webpack_exports, __webpack_require__) {



if (true) {
  module.exports = __webpack_require__(162);
} else // removed by dead control flow
{}


/***/ },

/***/ 314
(module) {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ },

/***/ 338
(__unused_webpack_module, exports, __webpack_require__) {



var m = __webpack_require__(206);
if (true) {
  exports.createRoot = m.createRoot;
  exports.hydrateRoot = m.hydrateRoot;
} else // removed by dead control flow
{ var i; }


/***/ },

/***/ 493
(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(594);
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is,
  useState = React.useState,
  useEffect = React.useEffect,
  useLayoutEffect = React.useLayoutEffect,
  useDebugValue = React.useDebugValue;
function useSyncExternalStore$2(subscribe, getSnapshot) {
  var value = getSnapshot(),
    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),
    inst = _useState[0].inst,
    forceUpdate = _useState[1];
  useLayoutEffect(
    function () {
      inst.value = value;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
    },
    [subscribe, value, getSnapshot]
  );
  useEffect(
    function () {
      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
      });
    },
    [subscribe]
  );
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot) {
  return getSnapshot();
}
var shim =
  "undefined" === typeof window ||
  "undefined" === typeof window.document ||
  "undefined" === typeof window.document.createElement
    ? useSyncExternalStore$1
    : useSyncExternalStore$2;
exports.useSyncExternalStore =
  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;


/***/ },

/***/ 540
(module) {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ },

/***/ 594
(module) {

module.exports = React;

/***/ },

/***/ 601
(module) {



module.exports = function (i) {
  return i[1];
};

/***/ },

/***/ 659
(module) {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ },

/***/ 825
(module) {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ },

/***/ 888
(module, __unused_webpack_exports, __webpack_require__) {



if (true) {
  module.exports = __webpack_require__(493);
} else // removed by dead control flow
{}


/***/ },

/***/ 912
(module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.plintus-editor {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    background: #f5f5f5;
}

.plintus-editor-content {
    flex: 1;
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: row;
}

.plintus-editor-canvas-wrapper {
    flex: 1;
    height: 100%;
    position: relative;
    min-width: 0; /* Allows flex item to shrink below its content size */
}




`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ 925
(module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.plintus-toolbar {
    display: flex;
    align-items: center;
    padding: 10px;
    background: #fff;
    border-bottom: 1px solid #ddd;
    justify-content: space-between;
}

.plintus-toolbar-section {
    display: flex;
    gap: 0;
    align-items: center;
}

.plintus-toolbar-section-right {
    margin-left: auto;
}

.plintus-tool-button {
    width: 36px;
    height: 36px;
    border: 1px solid #ddd;
    background: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    margin: 0;
    transition: all 0.2s;
}

.plintus-tool-button:hover {
    background: #f0f0f0;
    border-color: #0073aa;
}

.plintus-tool-button.active {
    background: #0073aa;
    color: #fff;
    border-color: #0073aa;
}

.plintus-toolbar button {
    width: 36px;
    height: 36px;
    border: 1px solid #ddd;
    background: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    margin: 0;
    transition: all 0.2s;
}

.plintus-toolbar button:hover {
    background: #f0f0f0;
    border-color: #0073aa;
}

.plintus-toolbar button.active {
    background: #0073aa;
    color: #fff;
    border-color: #0073aa;
}

.plintus-toolbar button i {
    font-size: 18px;
}






`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(594);
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(338);
;// ./node_modules/zustand/esm/vanilla.mjs
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if (( true ? {"NODE_ENV":"production"}.MODE : 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var vanilla = (createState) => {
  if (( true ? {"NODE_ENV":"production"}.MODE : 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
    );
  }
  return createStore(createState);
};



// EXTERNAL MODULE: ./node_modules/use-sync-external-store/shim/with-selector.js
var with_selector = __webpack_require__(242);
;// ./node_modules/zustand/esm/index.mjs





const { useDebugValue } = external_React_;
const { useSyncExternalStoreWithSelector } = with_selector;
let didWarnAboutEqualityFn = false;
const identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if (( true ? {"NODE_ENV":"production"}.MODE : 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  if (( true ? {"NODE_ENV":"production"}.MODE : 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createState ? createImpl(createState) : createImpl;
var react = (createState) => {
  if (( true ? {"NODE_ENV":"production"}.MODE : 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
    );
  }
  return create(createState);
};



;// ./admin/js/src/utils/geometry.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Вычисление расстояния между двумя точками
 */
function distance(point1, point2) {
  var dx = point2.x - point1.x;
  var dy = point2.y - point1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Конвертация миллиметров в пиксели (1 мм = 3.779527559 пикселей при 96 DPI)
 */
function mmToPixels(mm) {
  return mm * 3.779527559;
}

/**
 * Конвертация пикселей в миллиметры
 */
function pixelsToMM(pixels) {
  return pixels / 3.779527559;
}

/**
 * Форматирование длины в миллиметрах
 */
function formatLengthMM(lengthPixels) {
  var mm = pixelsToMM(lengthPixels);
  return "".concat(Math.round(mm * 10) / 10, " \u043C\u043C");
}

/**
 * Округление до ближайшего кратного значения
 */
function roundToMultiple(value, multiple) {
  return Math.round(value / multiple) * multiple;
}

/**
 * Привязка точки к сетке
 */
function snapToGrid(point, stepPixels) {
  return {
    x: roundToMultiple(point.x, stepPixels),
    y: roundToMultiple(point.y, stepPixels)
  };
}

/**
 * Проверка, является ли линия горизонтальной или вертикальной
 */
function isOrthogonal(point1, point2) {
  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
  var dx = Math.abs(point2.x - point1.x);
  var dy = Math.abs(point2.y - point1.y);
  return dx < tolerance || dy < tolerance;
}

/**
 * Приведение точки к ближайшей ортогональной (90 градусов)
 */
function snapToOrthogonal(start, end) {
  var dx = Math.abs(end.x - start.x);
  var dy = Math.abs(end.y - start.y);
  if (dx > dy) {
    // Горизонтальная линия
    return {
      x: end.x,
      y: start.y
    };
  } else {
    // Вертикальная линия
    return {
      x: start.x,
      y: end.y
    };
  }
}

/**
 * Проверка, находится ли точка на линии
 */
function isPointOnLine(point, lineStart, lineEnd) {
  var tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
  var dx = lineEnd.x - lineStart.x;
  var dy = lineEnd.y - lineStart.y;
  var length = Math.sqrt(dx * dx + dy * dy);
  if (length === 0) return false;
  var t = Math.max(0, Math.min(1, ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (length * length)));
  var projX = lineStart.x + t * dx;
  var projY = lineStart.y + t * dy;
  var dist = Math.sqrt(Math.pow(point.x - projX, 2) + Math.pow(point.y - projY, 2));
  return dist < tolerance;
}

/**
 * Вычисление угла между двумя точками (в градусах)
 */
function angle(point1, point2) {
  var dx = point2.x - point1.x;
  var dy = point2.y - point1.y;
  return Math.atan2(dy, dx) * (180 / Math.PI);
}

/**
 * Получение точки на указанном расстоянии от начальной точки под углом
 */
function pointAtDistance(start, angleDeg, distance) {
  var radians = angleDeg * Math.PI / 180;
  return {
    x: start.x + distance * Math.cos(radians),
    y: start.y + distance * Math.sin(radians)
  };
}

/**
 * Направление линии (нормализованный вектор)
 */
function lineDirection(line) {
  var dx = line.end.x - line.start.x;
  var dy = line.end.y - line.start.y;
  var length = Math.sqrt(dx * dx + dy * dy);
  if (length === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  return {
    x: dx / length,
    y: dy / length
  };
}

/**
 * Пересечение двух линий
 */
function lineIntersection(line1, line2) {
  var x1 = line1.start.x;
  var y1 = line1.start.y;
  var x2 = line1.end.x;
  var y2 = line1.end.y;
  var x3 = line2.start.x;
  var y3 = line2.start.y;
  var x4 = line2.end.x;
  var y4 = line2.end.y;
  var denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (Math.abs(denom) < 0.0001) {
    return null; // Линии параллельны
  }
  var t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
  var u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
  if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
    return {
      x: x1 + t * (x2 - x1),
      y: y1 + t * (y2 - y1)
    };
  }
  return null;
}

/**
 * Поиск точки соединения двух линий
 */
function findConnectionPoint(line1, line2) {
  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
  var p1 = line1.start;
  var p2 = line1.end;
  var p3 = line2.start;
  var p4 = line2.end;

  // Проверяем все возможные комбинации точек
  var points = [{
    point: p1,
    line1End: true,
    line2End: false
  }, {
    point: p2,
    line1End: true,
    line2End: false
  }, {
    point: p3,
    line1End: false,
    line2End: true
  }, {
    point: p4,
    line1End: false,
    line2End: true
  }];
  for (var i = 0; i < points.length; i++) {
    for (var j = i + 1; j < points.length; j++) {
      var dist = distance(points[i].point, points[j].point);
      if (dist < tolerance) {
        return _objectSpread(_objectSpread({}, points[i].point), {}, {
          line1End: points[i].line1End || points[j].line1End,
          line2End: points[i].line2End || points[j].line2End
        });
      }
    }
  }
  return null;
}

/**
 * Вычисление длины дуги
 */
function getArcLength(arc) {
  var radius = arc.radius;
  var angleRad = arc.angle * Math.PI / 180;
  return radius * angleRad;
}
;// ./admin/js/src/store/useEditorStore.js
function useEditorStore_typeof(o) { "@babel/helpers - typeof"; return useEditorStore_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, useEditorStore_typeof(o); }
function useEditorStore_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function useEditorStore_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? useEditorStore_ownKeys(Object(t), !0).forEach(function (r) { useEditorStore_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : useEditorStore_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function useEditorStore_defineProperty(e, r, t) { return (r = useEditorStore_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function useEditorStore_toPropertyKey(t) { var i = useEditorStore_toPrimitive(t, "string"); return "symbol" == useEditorStore_typeof(i) ? i : i + ""; }
function useEditorStore_toPrimitive(t, r) { if ("object" != useEditorStore_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != useEditorStore_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }


var useEditorStore = create(function (set, get) {
  return {
    // State
    elements: [],
    selectedElements: [],
    selectedTool: 'line',
    // 'line', 'arc', 'chamfer', 'select', 'delete'
    grid: {
      stepMM: 1,
      snap: true,
      visible: true,
      showMajorLines: false
    },
    dimensionsVisible: true,
    debugNumbersVisible: false,
    // Видимость номеров точек для отладки
    orthogonalSnap: true,
    // Ортогональная привязка включена по умолчанию
    viewbox: {
      x: 0,
      y: 0,
      width: 800,
      height: 400
    },
    isDrawing: false,
    currentLineStart: null,
    zoom: function () {
      // Вычисляем начальный масштаб на основе минимального при инициализации
      var gridStepPixels = mmToPixels(1); // Используем значение по умолчанию для grid.stepMM
      var minGridSizePixels = 5;
      var minZoom = Math.max(0.1, minGridSizePixels / gridStepPixels);
      // Начальный масштаб должен быть не меньше минимального, но не больше 2x
      return Math.max(minZoom, Math.min(2, minZoom * 2));
    }(),
    // Начальный масштаб вычисляется на основе минимального

    // Actions
    setSelectedTool: function setSelectedTool(tool) {
      return set({
        selectedTool: tool,
        selectedElements: []
      });
    },
    addElement: function addElement(element) {
      return set(function (state) {
        return {
          elements: [].concat(_toConsumableArray(state.elements), [useEditorStore_objectSpread(useEditorStore_objectSpread({}, element), {}, {
            id: "element-".concat(Date.now(), "-").concat(Math.random())
          })])
        };
      });
    },
    updateElement: function updateElement(id, updates) {
      return set(function (state) {
        return {
          elements: state.elements.map(function (el) {
            return el.id === id ? useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), updates) : el;
          })
        };
      });
    },
    deleteElement: function deleteElement(id) {
      return set(function (state) {
        // Находим элемент, который удаляется
        var elementToDelete = state.elements.find(function (el) {
          return el.id === id;
        });

        // Если это fillet или chamfer, восстанавливаем связанные линии
        if (elementToDelete && (elementToDelete.type === 'fillet' || elementToDelete.type === 'chamfer') && elementToDelete.connection) {
          var line1Id = elementToDelete.line1Id,
            line2Id = elementToDelete.line2Id,
            connection = elementToDelete.connection,
            line1EndTruncated = elementToDelete.line1EndTruncated,
            line2EndTruncated = elementToDelete.line2EndTruncated;

          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              location: 'useEditorStore.js:36',
              message: 'deleteElement fillet detected',
              data: {
                filletId: id,
                line1Id: line1Id,
                line2Id: line2Id,
                connection: connection,
                line1EndTruncated: line1EndTruncated,
                line2EndTruncated: line2EndTruncated
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'delete-fillet',
              hypothesisId: 'A'
            })
          })["catch"](function () {});
          // #endregion

          // Находим линии для определения, какой конец был обрезан (fallback для старых fillet)
          var line1 = state.elements.find(function (el) {
            return el.id === line1Id && el.type === 'line';
          });
          var line2 = state.elements.find(function (el) {
            return el.id === line2Id && el.type === 'line';
          });

          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              location: 'useEditorStore.js:50',
              message: 'deleteElement lines found',
              data: {
                line1Found: !!line1,
                line2Found: !!line2,
                line1: line1 ? {
                  start: line1.start,
                  end: line1.end
                } : null,
                line2: line2 ? {
                  start: line2.start,
                  end: line2.end
                } : null
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'delete-fillet',
              hypothesisId: 'A'
            })
          })["catch"](function () {});
          // #endregion

          // Определяем, какой конец обрезан, если информация не сохранена
          var shouldRestoreLine1End = line1EndTruncated;
          var shouldRestoreLine2End = line2EndTruncated;
          if (shouldRestoreLine1End === undefined && line1) {
            // Fallback: определяем по расстоянию до connection
            var distToLine1Start = distance(connection, line1.start);
            var distToLine1End = distance(connection, line1.end);
            shouldRestoreLine1End = distToLine1End < distToLine1Start;
          }
          if (shouldRestoreLine2End === undefined && line2) {
            // Fallback: определяем по расстоянию до connection
            var distToLine2Start = distance(connection, line2.start);
            var distToLine2End = distance(connection, line2.end);
            shouldRestoreLine2End = distToLine2End < distToLine2Start;
          }

          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              location: 'useEditorStore.js:70',
              message: 'deleteElement restoration logic',
              data: {
                shouldRestoreLine1End: shouldRestoreLine1End,
                shouldRestoreLine2End: shouldRestoreLine2End,
                connection: connection
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'delete-fillet',
              hypothesisId: 'A'
            })
          })["catch"](function () {});
          // #endregion

          // Восстанавливаем линии до исходного состояния
          var updatedElements = state.elements.map(function (el) {
            if (el.id === line1Id && el.type === 'line') {
              // Восстанавливаем line1
              var restored = shouldRestoreLine1End ? useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                end: connection
              }) : useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                start: connection
              });

              // #region agent log
              fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  location: 'useEditorStore.js:85',
                  message: 'deleteElement line1 restored',
                  data: {
                    line1Id: line1Id,
                    before: {
                      start: el.start,
                      end: el.end
                    },
                    after: {
                      start: restored.start,
                      end: restored.end
                    },
                    shouldRestoreLine1End: shouldRestoreLine1End
                  },
                  timestamp: Date.now(),
                  sessionId: 'debug-session',
                  runId: 'delete-fillet',
                  hypothesisId: 'A'
                })
              })["catch"](function () {});
              // #endregion

              return restored;
            } else if (el.id === line2Id && el.type === 'line') {
              // Восстанавливаем line2
              var _restored = shouldRestoreLine2End ? useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                end: connection
              }) : useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                start: connection
              });

              // #region agent log
              fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  location: 'useEditorStore.js:95',
                  message: 'deleteElement line2 restored',
                  data: {
                    line2Id: line2Id,
                    before: {
                      start: el.start,
                      end: el.end
                    },
                    after: {
                      start: _restored.start,
                      end: _restored.end
                    },
                    shouldRestoreLine2End: shouldRestoreLine2End
                  },
                  timestamp: Date.now(),
                  sessionId: 'debug-session',
                  runId: 'delete-fillet',
                  hypothesisId: 'A'
                })
              })["catch"](function () {});
              // #endregion

              return _restored;
            }
            return el;
          });

          // Удаляем fillet и обновляем линии
          return {
            elements: updatedElements.filter(function (el) {
              return el.id !== id;
            }),
            selectedElements: state.selectedElements.filter(function (el) {
              return el.id !== id;
            })
          };
        }

        // Обычное удаление
        return {
          elements: state.elements.filter(function (el) {
            return el.id !== id;
          }),
          selectedElements: state.selectedElements.filter(function (el) {
            return el.id !== id;
          })
        };
      });
    },
    deleteSelectedElements: function deleteSelectedElements() {
      return set(function (state) {
        var selectedIds = new Set(state.selectedElements.map(function (el) {
          return el.id;
        }));

        // Находим все fillet и chamfer среди выбранных элементов
        var filletsToDelete = state.selectedElements.filter(function (el) {
          return el.type === 'fillet';
        });
        var chamfersToDelete = state.selectedElements.filter(function (el) {
          return el.type === 'chamfer';
        });

        // Восстанавливаем линии для всех fillet и chamfer
        var updatedElements = _toConsumableArray(state.elements);
        var restoreLinesForElement = function restoreLinesForElement(element) {
          if (element.connection) {
            var line1Id = element.line1Id,
              line2Id = element.line2Id,
              connection = element.connection,
              line1EndTruncated = element.line1EndTruncated,
              line2EndTruncated = element.line2EndTruncated;

            // Находим линии для определения, какой конец был обрезан (fallback для старых элементов)
            var line1 = updatedElements.find(function (el) {
              return el.id === line1Id && el.type === 'line';
            });
            var line2 = updatedElements.find(function (el) {
              return el.id === line2Id && el.type === 'line';
            });

            // Определяем, какой конец обрезан, если информация не сохранена
            var shouldRestoreLine1End = line1EndTruncated;
            var shouldRestoreLine2End = line2EndTruncated;
            if (shouldRestoreLine1End === undefined && line1) {
              // Fallback: определяем по расстоянию до connection
              var distToLine1Start = distance(connection, line1.start);
              var distToLine1End = distance(connection, line1.end);
              shouldRestoreLine1End = distToLine1End < distToLine1Start;
            }
            if (shouldRestoreLine2End === undefined && line2) {
              // Fallback: определяем по расстоянию до connection
              var distToLine2Start = distance(connection, line2.start);
              var distToLine2End = distance(connection, line2.end);
              shouldRestoreLine2End = distToLine2End < distToLine2Start;
            }
            updatedElements = updatedElements.map(function (el) {
              if (el.id === line1Id && el.type === 'line') {
                // Восстанавливаем line1
                if (shouldRestoreLine1End) {
                  return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                    end: connection
                  });
                } else {
                  return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                    start: connection
                  });
                }
              } else if (el.id === line2Id && el.type === 'line') {
                // Восстанавливаем line2
                if (shouldRestoreLine2End) {
                  return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                    end: connection
                  });
                } else {
                  return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
                    start: connection
                  });
                }
              }
              return el;
            });
          }
        };
        filletsToDelete.forEach(restoreLinesForElement);
        chamfersToDelete.forEach(restoreLinesForElement);

        // Удаляем выбранные элементы
        return {
          elements: updatedElements.filter(function (el) {
            return !selectedIds.has(el.id);
          }),
          selectedElements: []
        };
      });
    },
    selectElement: function selectElement(element) {
      var isMultiSelect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return set(function (state) {
        if (!element) {
          return {
            selectedElements: []
          };
        }
        if (isMultiSelect) {
          var exists = state.selectedElements.some(function (el) {
            return el.id === element.id;
          });
          if (exists) {
            return {
              selectedElements: state.selectedElements.filter(function (el) {
                return el.id !== element.id;
              })
            };
          } else {
            return {
              selectedElements: [].concat(_toConsumableArray(state.selectedElements), [element])
            };
          }
        } else {
          return {
            selectedElements: [element]
          };
        }
      });
    },
    loadProfile: function loadProfile(data) {
      return set({
        elements: data.elements || [],
        grid: data.grid || {
          stepMM: 1,
          snap: true,
          visible: true,
          showMajorLines: false
        },
        viewbox: data.viewbox || {
          x: 0,
          y: 0,
          width: 800,
          height: 400
        }
      });
    },
    setCurrentLineStart: function setCurrentLineStart(point) {
      return set({
        currentLineStart: point
      });
    },
    setIsDrawing: function setIsDrawing(isDrawing) {
      return set({
        isDrawing: isDrawing
      });
    },
    toggleDimensionsVisible: function toggleDimensionsVisible() {
      return set(function (state) {
        return {
          dimensionsVisible: !state.dimensionsVisible
        };
      });
    },
    toggleDebugNumbersVisible: function toggleDebugNumbersVisible() {
      return set(function (state) {
        return {
          debugNumbersVisible: !state.debugNumbersVisible
        };
      });
    },
    toggleMajorLines: function toggleMajorLines() {
      return set(function (state) {
        return {
          grid: useEditorStore_objectSpread(useEditorStore_objectSpread({}, state.grid), {}, {
            showMajorLines: !state.grid.showMajorLines
          })
        };
      });
    },
    toggleOrthogonalSnap: function toggleOrthogonalSnap() {
      return set(function (state) {
        return {
          orthogonalSnap: !state.orthogonalSnap
        };
      });
    },
    updateFilletRadius: function updateFilletRadius(filletId, newRadiusMM) {
      return set(function (state) {
        var fillet = state.elements.find(function (el) {
          return el.id === filletId && el.type === 'fillet';
        });
        if (!fillet) return state;
        var newRadius = mmToPixels(newRadiusMM);
        var connection = fillet.connection,
          line1Direction = fillet.line1Direction,
          line2Direction = fillet.line2Direction,
          angle1 = fillet.angle1,
          angle2 = fillet.angle2,
          line1Id = fillet.line1Id,
          line2Id = fillet.line2Id,
          line1EndTruncated = fillet.line1EndTruncated,
          line2EndTruncated = fillet.line2EndTruncated;

        // Вычисляем новые точки начала и конца арки (используем сохраненные направления)
        var arcStartPoint = {
          x: connection.x + line1Direction.x * newRadius,
          y: connection.y + line1Direction.y * newRadius
        };
        var arcEndPoint = {
          x: connection.x + line2Direction.x * newRadius,
          y: connection.y + line2Direction.y * newRadius
        };

        // Вычисляем центр арки как пересечение перпендикуляров от точек арки к линиям
        // Используем тот же алгоритм, что и в createFilletAtCorner
        var dir1 = line1Direction;
        var dir2 = line2Direction;

        // Перпендикуляры к линиям от точек арки
        // Перпендикуляр к dir1 (поворот на 90° против часовой стрелки)
        var perp1Dir = {
          x: -dir1.y,
          y: dir1.x
        };
        // Перпендикуляр к dir2 (поворот на 90° против часовой стрелки)
        var perp2Dir = {
          x: -dir2.y,
          y: dir2.x
        };

        // Определяем направление перпендикуляров внутрь угла
        // Вычисляем направление биссектрисы для определения направления
        var bisectorDirUnnormalized = {
          x: dir1.x + dir2.x,
          y: dir1.y + dir2.y
        };
        var bisectorLength = Math.sqrt(bisectorDirUnnormalized.x * bisectorDirUnnormalized.x + bisectorDirUnnormalized.y * bisectorDirUnnormalized.y);
        var bisectorDir = bisectorLength > 0.0001 ? {
          x: bisectorDirUnnormalized.x / bisectorLength,
          y: bisectorDirUnnormalized.y / bisectorLength
        } : {
          x: -dir1.y,
          y: dir1.x
        };

        // Проверяем, направлены ли перпендикуляры внутрь угла
        var perp1Dot = perp1Dir.x * bisectorDir.x + perp1Dir.y * bisectorDir.y;
        var perp2Dot = perp2Dir.x * bisectorDir.x + perp2Dir.y * bisectorDir.y;
        var finalPerp1Dir = perp1Dot > 0 ? perp1Dir : {
          x: -perp1Dir.x,
          y: -perp1Dir.y
        };
        var finalPerp2Dir = perp2Dot > 0 ? perp2Dir : {
          x: -perp2Dir.x,
          y: -perp2Dir.y
        };

        // Пересечение прямых: arcStartPoint + t * finalPerp1Dir и arcEndPoint + s * finalPerp2Dir
        var dx = arcEndPoint.x - arcStartPoint.x;
        var dy = arcEndPoint.y - arcStartPoint.y;
        var denom = finalPerp1Dir.x * finalPerp2Dir.y - finalPerp1Dir.y * finalPerp2Dir.x;
        var arcCenter;
        if (Math.abs(denom) < 0.0001) {
          // Линии параллельны, используем fallback через биссектрису
          var angleDiff = Math.abs(angle2 - angle1);
          if (angleDiff > 180) {
            angleDiff = 360 - angleDiff;
          }
          var angleDiffRad = angleDiff * Math.PI / 180;
          var centerDist = angleDiffRad > 0.0001 ? newRadius / Math.sin(angleDiffRad / 2) : newRadius;
          arcCenter = {
            x: connection.x + bisectorDir.x * centerDist,
            y: connection.y + bisectorDir.y * centerDist
          };
        } else {
          var t = (dx * finalPerp2Dir.y - dy * finalPerp2Dir.x) / denom;
          arcCenter = {
            x: arcStartPoint.x + t * finalPerp1Dir.x,
            y: arcStartPoint.y + t * finalPerp1Dir.y
          };
        }

        // Вычисляем углы от центра к начальной и конечной точкам
        var arcStartAngleRad = Math.atan2(arcStartPoint.y - arcCenter.y, arcStartPoint.x - arcCenter.x);
        var arcEndAngleRad = Math.atan2(arcEndPoint.y - arcCenter.y, arcEndPoint.x - arcCenter.x);

        // Вычисляем угол дуги как разность углов от начальной точки к конечной
        var arcAngleRad = arcEndAngleRad - arcStartAngleRad;

        // Нормализуем угол к диапазону [-π, π]
        if (arcAngleRad > Math.PI) {
          arcAngleRad -= 2 * Math.PI;
        } else if (arcAngleRad < -Math.PI) {
          arcAngleRad += 2 * Math.PI;
        }
        var arcStartAngle = arcStartAngleRad * (180 / Math.PI);
        if (arcStartAngle > 180) arcStartAngle -= 360;
        if (arcStartAngle < -180) arcStartAngle += 360;

        // Угол дуги всегда должен быть положительным
        var arcAngle = Math.abs(arcAngleRad) * (180 / Math.PI);

        // Находим линии для обрезки
        var line1 = state.elements.find(function (el) {
          return el.id === line1Id;
        });
        var line2 = state.elements.find(function (el) {
          return el.id === line2Id;
        });
        if (!line1 || !line2) return state;

        // Сохраняем исходные длины
        var originalLine1Length = line1.length || distance(line1.start, line1.end);
        var originalLine2Length = line2.length || distance(line2.start, line2.end);

        // Используем сохраненную информацию о том, какой конец обрезается
        // Если line1EndTruncated undefined (старые fillet без этой информации), используем расстояние как fallback
        var shouldTruncateLine1End = line1EndTruncated;
        var shouldTruncateLine2End = line2EndTruncated;

        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            location: 'useEditorStore.js:127',
            message: 'updateFilletRadius truncation check',
            data: {
              line1EndTruncated: line1EndTruncated,
              line2EndTruncated: line2EndTruncated,
              line1: {
                start: line1.start,
                end: line1.end
              },
              line2: {
                start: line2.start,
                end: line2.end
              },
              connection: connection
            },
            timestamp: Date.now(),
            sessionId: 'debug-session',
            runId: 'initial',
            hypothesisId: 'A'
          })
        })["catch"](function () {});
        // #endregion

        if (shouldTruncateLine1End === undefined || shouldTruncateLine2End === undefined) {
          // Fallback для старых fillet: определяем по расстоянию до connection
          var distToLine1Start = distance(connection, line1.start);
          var distToLine1End = distance(connection, line1.end);
          var distToLine2Start = distance(connection, line2.start);
          var distToLine2End = distance(connection, line2.end);
          shouldTruncateLine1End = distToLine1End < distToLine1Start;
          shouldTruncateLine2End = distToLine2End < distToLine2Start;

          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              location: 'useEditorStore.js:138',
              message: 'updateFilletRadius fallback calculation',
              data: {
                distToLine1Start: distToLine1Start,
                distToLine1End: distToLine1End,
                distToLine2Start: distToLine2Start,
                distToLine2End: distToLine2End,
                shouldTruncateLine1End: shouldTruncateLine1End,
                shouldTruncateLine2End: shouldTruncateLine2End
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'initial',
              hypothesisId: 'A'
            })
          })["catch"](function () {});
          // #endregion
        }

        // Обновляем элементы
        var updatedElements = state.elements.map(function (el) {
          if (el.id === filletId) {
            // Обновляем fillet
            var updatedFillet = useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
              radius: newRadius,
              arc: {
                center: arcCenter,
                radius: newRadius,
                startAngle: arcStartAngle,
                angle: arcAngle
              },
              arcStartPoint: arcStartPoint,
              arcEndPoint: arcEndPoint,
              line1EndTruncated: shouldTruncateLine1End,
              line2EndTruncated: shouldTruncateLine2End
            });

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                location: 'useEditorStore.js:150',
                message: 'updateFilletRadius fillet update',
                data: {
                  filletId: filletId,
                  newRadius: newRadius,
                  arcStartPoint: arcStartPoint,
                  arcEndPoint: arcEndPoint,
                  shouldTruncateLine1End: shouldTruncateLine1End,
                  shouldTruncateLine2End: shouldTruncateLine2End
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'initial',
                hypothesisId: 'B'
              })
            })["catch"](function () {});
            // #endregion

            return updatedFillet;
          } else if (el.id === line1Id) {
            // Обрезаем line1 используя сохраненную информацию
            var update = shouldTruncateLine1End ? {
              end: arcStartPoint,
              length: originalLine1Length
            } : {
              start: arcStartPoint,
              length: originalLine1Length
            };

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                location: 'useEditorStore.js:162',
                message: 'updateFilletRadius line1 update',
                data: {
                  line1Id: line1Id,
                  update: update,
                  shouldTruncateLine1End: shouldTruncateLine1End,
                  arcStartPoint: arcStartPoint,
                  originalLine1Length: originalLine1Length
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'initial',
                hypothesisId: 'B'
              })
            })["catch"](function () {});
            // #endregion

            return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), update);
          } else if (el.id === line2Id) {
            // Обрезаем line2 используя сохраненную информацию
            var _update = shouldTruncateLine2End ? {
              end: arcEndPoint,
              length: originalLine2Length
            } : {
              start: arcEndPoint,
              length: originalLine2Length
            };

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                location: 'useEditorStore.js:173',
                message: 'updateFilletRadius line2 update',
                data: {
                  line2Id: line2Id,
                  update: _update,
                  shouldTruncateLine2End: shouldTruncateLine2End,
                  arcEndPoint: arcEndPoint,
                  originalLine2Length: originalLine2Length
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'initial',
                hypothesisId: 'B'
              })
            })["catch"](function () {});
            // #endregion

            return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), _update);
          }
          return el;
        });
        return {
          elements: updatedElements
        };
      });
    },
    updateChamferDepth: function updateChamferDepth(chamferId, newDepthMM) {
      return set(function (state) {
        var chamfer = state.elements.find(function (el) {
          return el.id === chamferId && el.type === 'chamfer';
        });
        if (!chamfer) return state;
        var newDepth = mmToPixels(newDepthMM);
        var connection = chamfer.connection,
          line1Direction = chamfer.line1Direction,
          line2Direction = chamfer.line2Direction,
          line1Id = chamfer.line1Id,
          line2Id = chamfer.line2Id,
          line1EndTruncated = chamfer.line1EndTruncated,
          line2EndTruncated = chamfer.line2EndTruncated;

        // Вычисляем точки обрезки на линиях на расстоянии newDepth от connection
        var chamferStartPoint = {
          x: connection.x + line1Direction.x * newDepth,
          y: connection.y + line1Direction.y * newDepth
        };
        var chamferEndPoint = {
          x: connection.x + line2Direction.x * newDepth,
          y: connection.y + line2Direction.y * newDepth
        };

        // Находим линии для обрезки
        var line1 = state.elements.find(function (el) {
          return el.id === line1Id;
        });
        var line2 = state.elements.find(function (el) {
          return el.id === line2Id;
        });
        if (!line1 || !line2) return state;

        // Сохраняем исходные длины
        var originalLine1Length = line1.length || distance(line1.start, line1.end);
        var originalLine2Length = line2.length || distance(line2.start, line2.end);

        // Обновляем элементы
        var updatedElements = state.elements.map(function (el) {
          if (el.id === chamferId) {
            // Обновляем chamfer
            return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), {}, {
              depth: newDepth,
              start: chamferStartPoint,
              end: chamferEndPoint
            });
          } else if (el.id === line1Id) {
            // Обрезаем line1
            var update = line1EndTruncated ? {
              end: chamferStartPoint,
              length: originalLine1Length
            } : {
              start: chamferStartPoint,
              length: originalLine1Length
            };
            return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), update);
          } else if (el.id === line2Id) {
            // Обрезаем line2
            var _update2 = line2EndTruncated ? {
              end: chamferEndPoint,
              length: originalLine2Length
            } : {
              start: chamferEndPoint,
              length: originalLine2Length
            };
            return useEditorStore_objectSpread(useEditorStore_objectSpread({}, el), _update2);
          }
          return el;
        });
        return {
          elements: updatedElements
        };
      });
    },
    // Вычисляет минимальный масштаб на основе размера сетки
    // Минимальный масштаб должен быть таким, чтобы сетка была видна (минимум 5 пикселей между линиями)
    getMinZoom: function getMinZoom() {
      var state = get();
      var gridStepPixels = mmToPixels(state.grid.stepMM);
      var minGridSizePixels = 5; // Минимальный размер сетки в пикселях для видимости
      var minZoom = minGridSizePixels / gridStepPixels;
      return Math.max(0.1, minZoom); // Минимум 0.1x для безопасности
    },
    zoomIn: function zoomIn() {
      return set(function (state) {
        var newZoom = Math.min(state.zoom * 1.2, 10); // Максимальный масштаб 10x
        return {
          zoom: newZoom
        };
      });
    },
    zoomOut: function zoomOut() {
      var state = get();
      var gridStepPixels = mmToPixels(state.grid.stepMM);
      var minGridSizePixels = 5; // Минимальный размер сетки в пикселях для видимости
      var minZoom = Math.max(0.1, minGridSizePixels / gridStepPixels);

      // Если текущий масштаб уже равен минимальному (или очень близок к нему), не уменьшаем
      if (Math.abs(state.zoom - minZoom) < 0.001 || state.zoom <= minZoom) {
        return; // Не изменяем масштаб, если он уже на минимальном уровне
      }
      var newZoom = Math.max(state.zoom / 1.2, minZoom); // Минимальный масштаб на основе размера сетки
      return set({
        zoom: newZoom
      });
    },
    resetZoom: function resetZoom() {
      var state = get();
      var gridStepPixels = mmToPixels(state.grid.stepMM);
      var minGridSizePixels = 5; // Минимальный размер сетки в пикселях для видимости
      var minZoom = Math.max(0.1, minGridSizePixels / gridStepPixels);
      // Начальный масштаб должен быть не меньше минимального, но не больше 2x
      var initialZoom = Math.max(minZoom, Math.min(2, minZoom * 2));
      return set({
        zoom: initialZoom
      });
    },
    setZoom: function setZoom(zoom) {
      var state = get();
      var gridStepPixels = mmToPixels(state.grid.stepMM);
      var minGridSizePixels = 5; // Минимальный размер сетки в пикселях для видимости
      var minZoom = Math.max(0.1, minGridSizePixels / gridStepPixels);
      return set({
        zoom: Math.max(minZoom, Math.min(10, zoom))
      }); // Установка масштаба с ограничениями
    }
  };
});
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(72);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(825);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(659);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(56);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(540);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(113);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./admin/js/src/components/Canvas/CanvasEditor.css
var CanvasEditor = __webpack_require__(52);
;// ./admin/js/src/components/Canvas/CanvasEditor.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(CanvasEditor/* default */.A, options);




       /* harmony default export */ const Canvas_CanvasEditor = (CanvasEditor/* default */.A && CanvasEditor/* default */.A.locals ? CanvasEditor/* default */.A.locals : undefined);

;// ./admin/js/src/components/Canvas/CanvasEditor.jsx
function CanvasEditor_typeof(o) { "@babel/helpers - typeof"; return CanvasEditor_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, CanvasEditor_typeof(o); }
function CanvasEditor_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function CanvasEditor_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? CanvasEditor_ownKeys(Object(t), !0).forEach(function (r) { CanvasEditor_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : CanvasEditor_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function CanvasEditor_defineProperty(e, r, t) { return (r = CanvasEditor_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function CanvasEditor_toPropertyKey(t) { var i = CanvasEditor_toPrimitive(t, "string"); return "symbol" == CanvasEditor_typeof(i) ? i : i + ""; }
function CanvasEditor_toPrimitive(t, r) { if ("object" != CanvasEditor_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != CanvasEditor_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = CanvasEditor_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || CanvasEditor_unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function CanvasEditor_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return CanvasEditor_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? CanvasEditor_arrayLikeToArray(r, a) : void 0; } }
function CanvasEditor_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }





function CanvasEditor_CanvasEditor() {
  var canvasRef = (0,external_React_.useRef)(null);
  var containerRef = (0,external_React_.useRef)(null);
  var paperScopeRef = (0,external_React_.useRef)(null);
  var _useState = (0,external_React_.useState)(null),
    _useState2 = _slicedToArray(_useState, 2),
    paperProject = _useState2[0],
    setPaperProject = _useState2[1];
  var _useState3 = (0,external_React_.useState)({
      width: 800,
      height: 400
    }),
    _useState4 = _slicedToArray(_useState3, 2),
    containerSize = _useState4[0],
    setContainerSize = _useState4[1];
  var _useState5 = (0,external_React_.useState)(null),
    _useState6 = _slicedToArray(_useState5, 2),
    draggingPoint = _useState6[0],
    setDraggingPoint = _useState6[1]; // Array of { elementId, pointType: 'start' | 'end' }
  var _useState7 = (0,external_React_.useState)(null),
    _useState8 = _slicedToArray(_useState7, 2),
    hoveredPoint = _useState8[0],
    setHoveredPoint = _useState8[1]; // { elementId, pointType: 'start' | 'end' }
  var _useState9 = (0,external_React_.useState)(false),
    _useState0 = _slicedToArray(_useState9, 2),
    isPanning = _useState0[0],
    setIsPanning = _useState0[1]; // Состояние для перетаскивания view
  var _useState1 = (0,external_React_.useState)(null),
    _useState10 = _slicedToArray(_useState1, 2),
    panStartPoint = _useState10[0],
    setPanStartPoint = _useState10[1]; // Начальная точка для pan
  var _useState11 = (0,external_React_.useState)(null),
    _useState12 = _slicedToArray(_useState11, 2),
    initialViewCenter = _useState12[0],
    setInitialViewCenter = _useState12[1]; // Исходный центр view
  var isMiddleButtonPressedRef = (0,external_React_.useRef)(false); // Флаг для отслеживания средней кнопки мыши

  var _useEditorStore = useEditorStore(),
    elements = _useEditorStore.elements,
    selectedElements = _useEditorStore.selectedElements,
    selectedTool = _useEditorStore.selectedTool,
    grid = _useEditorStore.grid,
    dimensionsVisible = _useEditorStore.dimensionsVisible,
    debugNumbersVisible = _useEditorStore.debugNumbersVisible,
    orthogonalSnap = _useEditorStore.orthogonalSnap,
    currentLineStart = _useEditorStore.currentLineStart,
    isDrawing = _useEditorStore.isDrawing,
    setCurrentLineStart = _useEditorStore.setCurrentLineStart,
    setIsDrawing = _useEditorStore.setIsDrawing,
    addElement = _useEditorStore.addElement,
    deleteElement = _useEditorStore.deleteElement,
    selectElement = _useEditorStore.selectElement,
    deleteSelectedElements = _useEditorStore.deleteSelectedElements,
    updateElement = _useEditorStore.updateElement;
  var gridStepPixels = mmToPixels(grid.stepMM);
  var viewbox = useEditorStore(function (state) {
    return state.viewbox;
  });
  var zoom = useEditorStore(function (state) {
    return state.zoom;
  });
  var _useEditorStore2 = useEditorStore(),
    zoomIn = _useEditorStore2.zoomIn,
    zoomOut = _useEditorStore2.zoomOut,
    setZoom = _useEditorStore2.setZoom,
    resetZoom = _useEditorStore2.resetZoom;
  var prevZoomRef = (0,external_React_.useRef)(zoom); // Для отслеживания изменений zoom

  // Обновление размеров контейнера
  (0,external_React_.useEffect)(function () {
    var updateSize = function updateSize() {
      if (containerRef.current) {
        var rect = containerRef.current.getBoundingClientRect();
        setContainerSize({
          width: rect.width,
          height: rect.height
        });
      }
    };
    updateSize();
    window.addEventListener('resize', updateSize);
    return function () {
      return window.removeEventListener('resize', updateSize);
    };
  }, []);

  // Инициализация Paper.js
  (0,external_React_.useEffect)(function () {
    if (!canvasRef.current) {
      return;
    }

    // Ждем загрузки Paper.js
    if (typeof paper === 'undefined') {
      var checkPaper = setInterval(function () {
        if (typeof paper !== 'undefined') {
          clearInterval(checkPaper);
          initializePaper();
        }
      }, 100);
      return function () {
        return clearInterval(checkPaper);
      };
    } else {
      initializePaper();
    }
    function initializePaper() {
      if (!canvasRef.current) return;
      var canvas = canvasRef.current;
      var width = containerSize.width || viewbox.width;
      var height = containerSize.height || viewbox.height;

      // Устанавливаем размеры canvas через атрибуты (не CSS!)
      canvas.width = width;
      canvas.height = height;

      // Создаем новый scope для Paper.js
      var scope = new paper.PaperScope();
      scope.setup(canvas);

      // Устанавливаем начальный масштаб
      scope.activate();
      // Получаем начальный масштаб из store и убеждаемся, что он не меньше минимального
      var state = useEditorStore.getState();
      var minZoom = state.getMinZoom();
      var initialZoom = state.zoom;
      // Убеждаемся, что начальный масштаб не меньше минимального
      if (initialZoom < minZoom) {
        initialZoom = Math.max(minZoom, Math.min(2, minZoom * 2));
        useEditorStore.setState({
          zoom: initialZoom
        });
      }
      var centerPoint = new paper.Point(width / 2, height / 2);
      scope.view.scale(initialZoom, centerPoint);

      // Устанавливаем центр view так, чтобы центр сетки был в центре видимой области
      // Центр сетки в координатах проекта: (viewbox.width/2, viewbox.height/2)
      var gridCenterX = viewbox.width / 2;
      var gridCenterY = viewbox.height / 2;
      scope.view.center = new paper.Point(gridCenterX, gridCenterY);

      // Сохраняем исходный центр view
      setInitialViewCenter(scope.view.center.clone());

      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          location: 'CanvasEditor.jsx:101',
          message: 'initial view center saved',
          data: {
            initialViewCenter: scope.view.center,
            viewCenter: scope.view.center,
            width: width,
            height: height,
            initialZoom: initialZoom,
            centerPoint: centerPoint,
            gridCenterX: gridCenterX,
            gridCenterY: gridCenterY
          },
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'reset-view',
          hypothesisId: 'A'
        })
      })["catch"](function () {});
      // #endregion

      paperScopeRef.current = scope;
      setPaperProject(scope.project);
    }

    // Очистка при размонтировании
    return function () {
      if (paperScopeRef.current) {
        paperScopeRef.current.remove();
      }
    };
  }, []); // Инициализация только один раз

  // Обновление размеров canvas при изменении размеров контейнера
  (0,external_React_.useEffect)(function () {
    if (!canvasRef.current || !paperScopeRef.current) {
      return;
    }
    var canvas = canvasRef.current;
    var width = containerSize.width || viewbox.width;
    var height = containerSize.height || viewbox.height;

    // Обновляем размеры canvas
    if (canvas.width !== width || canvas.height !== height) {
      canvas.width = width;
      canvas.height = height;

      // Обновляем размеры view в Paper.js
      var scope = paperScopeRef.current;
      scope.activate();
      scope.view.viewSize = new paper.Size(width, height);
      scope.view.draw();
    }
  }, [containerSize.width, containerSize.height, viewbox.width, viewbox.height]);

  // Обновление масштаба при изменении zoom (только при программном изменении через кнопки)
  // Масштабирование через wheel обрабатывается отдельно с учетом позиции курсора
  (0,external_React_.useEffect)(function () {
    if (!paperScopeRef.current) {
      return;
    }
    var scope = paperScopeRef.current;
    scope.activate();
    var width = containerSize.width || viewbox.width;
    var height = containerSize.height || viewbox.height;

    // Проверяем, был ли сброс масштаба (zoom вернулся к начальному значению)
    // Начальное значение - это минимальный масштаб или 2x, в зависимости от того, что больше
    var minZoom = useEditorStore.getState().getMinZoom();
    var initialZoom = Math.max(minZoom, Math.min(2, minZoom * 2));
    var wasReset = prevZoomRef.current !== initialZoom && Math.abs(zoom - initialZoom) < 0.01;
    prevZoomRef.current = zoom;

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:150',
        message: 'zoom change',
        data: {
          zoom: zoom,
          wasReset: wasReset,
          prevZoom: prevZoomRef.current,
          initialViewCenter: initialViewCenter,
          currentViewCenter: scope.view.center
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'reset-view',
        hypothesisId: 'B'
      })
    })["catch"](function () {});
    // #endregion

    // Вычисляем текущий масштаб view
    var currentScale = scope.view.zoom || 1;
    var scaleFactor = zoom / currentScale;
    var centerPoint = new paper.Point(width / 2, height / 2);

    // При программном изменении масштабируем относительно центра canvas
    scope.view.scale(scaleFactor, centerPoint);

    // Если был сброс, устанавливаем центр view так, чтобы центр сетки был в центре видимой области
    // Это гарантирует, что сетка будет в центре без пустого пространства
    if (wasReset) {
      // Центр сетки в координатах проекта: (viewbox.width/2, viewbox.height/2)
      var gridCenterX = viewbox.width / 2;
      var gridCenterY = viewbox.height / 2;
      scope.view.center = new paper.Point(gridCenterX, gridCenterY);
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          location: 'CanvasEditor.jsx:175',
          message: 'view center reset to grid center',
          data: {
            wasReset: wasReset,
            gridCenterX: gridCenterX,
            gridCenterY: gridCenterY,
            viewCenter: scope.view.center,
            centerPoint: centerPoint,
            zoom: zoom,
            currentScale: currentScale,
            scaleFactor: scaleFactor
          },
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'reset-view',
          hypothesisId: 'E'
        })
      })["catch"](function () {});
      // #endregion
    }
    scope.view.draw();
  }, [zoom, containerSize.width, containerSize.height, viewbox.width, viewbox.height, initialViewCenter]);

  // Обработчик прокрутки колесика мыши для масштабирования относительно позиции курсора
  (0,external_React_.useEffect)(function () {
    var canvas = canvasRef.current;
    if (!canvas || !paperScopeRef.current) return;
    var handleWheel = function handleWheel(event) {
      event.preventDefault();
      event.stopPropagation();
      var scope = paperScopeRef.current;
      if (!scope) return;
      scope.activate();

      // Получаем позицию курсора в координатах view (экранные координаты)
      var rect = canvas.getBoundingClientRect();
      var mousePoint = new paper.Point(event.clientX - rect.left, event.clientY - rect.top);

      // Вычисляем точку в координатах проекта (world coordinates)
      var viewPoint = scope.view.viewToProject(mousePoint);
      var delta = event.deltaY;
      var zoomFactor = delta > 0 ? 0.9 : 1.1; // Уменьшение при прокрутке вниз, увеличение при прокрутке вверх

      var currentZoom = useEditorStore.getState().zoom;
      var minZoom = useEditorStore.getState().getMinZoom();
      var newZoom = Math.max(minZoom, Math.min(10, currentZoom * zoomFactor));

      // Если масштаб не изменился (уже на минимальном или максимальном уровне), не применяем изменения
      if (Math.abs(newZoom - currentZoom) < 0.001) {
        return; // Не изменяем масштаб, если он уже на границе
      }

      // Применяем масштабирование относительно позиции курсора
      var scaleFactor = newZoom / currentZoom;
      scope.view.scale(scaleFactor, viewPoint);

      // Обновляем zoom в store
      setZoom(newZoom);
    };
    canvas.addEventListener('wheel', handleWheel, {
      passive: false
    });
    return function () {
      canvas.removeEventListener('wheel', handleWheel);
    };
  }, [setZoom]);

  // Глобальный обработчик для отслеживания средней кнопки мыши
  (0,external_React_.useEffect)(function () {
    var handleGlobalMouseDown = function handleGlobalMouseDown(event) {
      // Проверяем, что событие происходит на canvas
      var canvas = canvasRef.current;
      if (!canvas) {
        return;
      }
      var target = event.target;
      if (target !== canvas && !canvas.contains(target)) {
        return;
      }

      // Проверяем, что нажата средняя кнопка мыши (колесико) или зажато колесико
      var isMiddleButton = event.button === 1 || event.buttons === 4 || event.which === 2;
      if (isMiddleButton) {
        // Устанавливаем флаг, что средняя кнопка нажата
        isMiddleButtonPressedRef.current = true;
      } else {
        // Сбрасываем флаг для других кнопок
        isMiddleButtonPressedRef.current = false;
      }
    };

    // Используем capture phase для установки флага ДО того, как Paper.js обработает событие,
    // но НЕ блокируем событие - пусть оно доходит до Paper.js tool, где мы его заблокируем
    document.addEventListener('mousedown', handleGlobalMouseDown, true);
    return function () {
      document.removeEventListener('mousedown', handleGlobalMouseDown, true);
    };
  }, []);

  // Обработчик перетаскивания view при зажатом колесике мыши
  (0,external_React_.useEffect)(function () {
    var canvas = canvasRef.current;
    if (!canvas || !paperScopeRef.current) return;
    var scope = paperScopeRef.current;
    var handleMouseDown = function handleMouseDown(event) {
      // Проверяем, что нажата средняя кнопка мыши (колесико) или зажато колесико
      var isMiddleButton = event.button === 1 || event.buttons === 4 || event.which === 2;
      if (isMiddleButton) {
        // Устанавливаем флаг, что средняя кнопка нажата
        isMiddleButtonPressedRef.current = true;

        // НЕ блокируем событие здесь - пусть оно доходит до Paper.js tool,
        // где мы его заблокируем через проверку флага

        setIsPanning(true);
        var rect = canvas.getBoundingClientRect();
        setPanStartPoint({
          x: event.clientX - rect.left,
          y: event.clientY - rect.top,
          viewCenter: scope.view.center.clone()
        });
      } else {
        // Сбрасываем флаг для других кнопок
        isMiddleButtonPressedRef.current = false;
      }
    };
    var handleMouseMove = function handleMouseMove(event) {
      if (!isPanning || !panStartPoint) return;
      event.preventDefault();
      event.stopPropagation();
      scope.activate();
      var rect = canvas.getBoundingClientRect();
      var currentViewPoint = new paper.Point(event.clientX - rect.left, event.clientY - rect.top);
      var startViewPoint = new paper.Point(panStartPoint.x, panStartPoint.y);

      // Вычисляем смещение в экранных координатах (view coordinates)
      var deltaView = currentViewPoint.subtract(startViewPoint);

      // Преобразуем смещение в координаты проекта (world coordinates)
      // Для этого используем текущий масштаб view
      var zoom = scope.view.zoom || 1;
      var deltaProject = deltaView.divide(zoom);

      // Вычисляем новое положение центра view
      var newCenter = panStartPoint.viewCenter.subtract(deltaProject);

      // Ограничиваем перемещение границами сетки
      // Границы сетки: от (0, 0) до (viewbox.width, viewbox.height)
      var gridMinX = 0;
      var gridMinY = 0;
      var gridMaxX = viewbox.width;
      var gridMaxY = viewbox.height;

      // Размер видимой области в координатах проекта
      var viewWidth = (containerSize.width || viewbox.width) / zoom;
      var viewHeight = (containerSize.height || viewbox.height) / zoom;

      // Границы для центра view (чтобы сетка всегда была видна)
      // Левая граница видимой области = center.x - viewWidth/2
      // Правая граница видимой области = center.x + viewWidth/2
      // Верхняя граница видимой области = center.y - viewHeight/2
      // Нижняя граница видимой области = center.y + viewHeight/2

      // Если видимая область больше сетки, центр должен быть в центре сетки
      var minCenterX, maxCenterX, minCenterY, maxCenterY;
      if (viewWidth >= gridMaxX) {
        // Видимая область больше или равна сетке по ширине - центр должен быть в центре сетки
        minCenterX = maxCenterX = gridMaxX / 2;
      } else {
        // Видимая область меньше сетки - ограничиваем перемещение
        minCenterX = gridMinX + viewWidth / 2;
        maxCenterX = gridMaxX - viewWidth / 2;
      }
      if (viewHeight >= gridMaxY) {
        // Видимая область больше или равна сетке по высоте - центр должен быть в центре сетки
        minCenterY = maxCenterY = gridMaxY / 2;
      } else {
        // Видимая область меньше сетки - ограничиваем перемещение
        minCenterY = gridMinY + viewHeight / 2;
        maxCenterY = gridMaxY - viewHeight / 2;
      }

      // Ограничиваем центр view границами
      var clampedCenterX = Math.max(minCenterX, Math.min(maxCenterX, newCenter.x));
      var clampedCenterY = Math.max(minCenterY, Math.min(maxCenterY, newCenter.y));

      // Устанавливаем ограниченный центр view
      scope.view.center = new paper.Point(clampedCenterX, clampedCenterY);
      scope.view.draw();
    };
    var handleMouseUp = function handleMouseUp(event) {
      if (event.button === 1 || event.buttons === 0) {
        setIsPanning(false);
        setPanStartPoint(null);
        // Сбрасываем флаг средней кнопки мыши
        isMiddleButtonPressedRef.current = false;
      }
    };
    var handleContextMenu = function handleContextMenu(event) {
      // Предотвращаем контекстное меню при зажатом колесике
      if (event.button === 1) {
        event.preventDefault();
      }
    };

    // НЕ используем capture phase - пусть Paper.js обработает событие первым,
    // а мы только установим флаг для последующей проверки в tool.onMouseDown
    canvas.addEventListener('mousedown', handleMouseDown, false); // false = bubble phase
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
    canvas.addEventListener('contextmenu', handleContextMenu);
    return function () {
      canvas.removeEventListener('mousedown', handleMouseDown, false); // false = bubble phase
      canvas.removeEventListener('mousemove', handleMouseMove);
      canvas.removeEventListener('mouseup', handleMouseUp);
      canvas.removeEventListener('mouseleave', handleMouseUp);
      canvas.removeEventListener('contextmenu', handleContextMenu);
    };
  }, [isPanning, panStartPoint]);

  // Отрисовка элементов на canvas
  (0,external_React_.useEffect)(function () {
    if (!paperProject || !paperScopeRef.current) {
      return;
    }
    var scope = paperScopeRef.current;
    scope.activate();

    // Очищаем canvas
    scope.project.clear();

    // Отрисовываем сетку
    if (grid.visible) {
      drawGrid(scope, gridStepPixels, false);
    }

    // Находим все fillet и chamfer для проверки выделения линий
    var fillets = elements.filter(function (el) {
      return el.type === 'fillet';
    });
    var chamfers = elements.filter(function (el) {
      return el.type === 'chamfer';
    });
    var lineIdsInSelectedFillets = new Set();
    var lineIdsInSelectedChamfers = new Set();
    selectedElements.forEach(function (sel) {
      if (sel.type === 'fillet') {
        if (sel.line1Id) lineIdsInSelectedFillets.add(sel.line1Id);
        if (sel.line2Id) lineIdsInSelectedFillets.add(sel.line2Id);
      }
      if (sel.type === 'chamfer') {
        if (sel.line1Id) lineIdsInSelectedChamfers.add(sel.line1Id);
        if (sel.line2Id) lineIdsInSelectedChamfers.add(sel.line2Id);
      }
    });

    // Присваиваем номера концам линий для визуализации
    var pointNumberMap = assignPointNumbers(elements);

    // Отрисовываем элементы
    elements.forEach(function (element) {
      var isSelected = selectedElements.some(function (sel) {
        return sel.id === element.id;
      });
      if (element.type === 'line') {
        // Если линия входит в выбранный fillet или chamfer, выделяем её
        var shouldHighlight = lineIdsInSelectedFillets.has(element.id) || lineIdsInSelectedChamfers.has(element.id);
        drawLine(scope, element, isSelected || shouldHighlight, false, null, pointNumberMap);
      } else if (element.type === 'arc') {
        drawArc(scope, element, isSelected);
      } else if (element.type === 'fillet') {
        drawFillet(scope, element, isSelected, elements, pointNumberMap);
      } else if (element.type === 'chamfer') {
        drawChamfer(scope, element, isSelected, elements, pointNumberMap);
      }
    });

    // В режиме "Скругление" или "Фаска" отображаем все точки соединений между линиями
    // Отрисовываем ПОСЛЕ всех элементов, чтобы точки были видны поверх
    if (selectedTool === 'arc' || selectedTool === 'chamfer') {
      var connectionPoints = findAllConnectionPoints(elements);
      connectionPoints.forEach(function (cp, index) {
        // Создаем круг для точки соединения
        var circle = new paper.Path.Circle({
          center: [cp.point.x, cp.point.y],
          radius: 1.6,
          fillColor: '#ff6600',
          strokeColor: '#fff',
          strokeWidth: 2
        });
        circle.data = {
          type: 'connectionPoint',
          connectionPoint: cp,
          index: index
        };
        // Перемещаем на передний план, чтобы точка была видна
        circle.bringToFront();
      });
    }

    // Временная линия будет отрисовываться в обработчике onMouseMove
    // Здесь не отрисовываем её, чтобы избежать ошибок при отсутствии события

    scope.view.draw();
  }, [elements, selectedElements, grid, dimensionsVisible, debugNumbersVisible, paperProject, gridStepPixels, selectedTool]);

  // Обработка событий мыши
  (0,external_React_.useEffect)(function () {
    if (!paperProject || !paperScopeRef.current) {
      return;
    }
    var scope = paperScopeRef.current;
    scope.activate();
    var tool = new paper.Tool();
    tool.onMouseDown = function (event) {
      // Проверяем, что нажата средняя кнопка мыши (колесико) - блокируем обработку
      // Проверяем все возможные способы определения средней кнопки
      var checkMiddleButton = function checkMiddleButton(evt) {
        if (!evt) return false;
        return evt.button === 1 || evt.buttons === 4 || evt.which === 2;
      };
      var nativeEvent = event.event || event.originalEvent;
      var isMiddleButton = checkMiddleButton(nativeEvent) || checkMiddleButton(window.event) || isMiddleButtonPressedRef.current;
      if (isMiddleButton) {
        return; // Выходим немедленно, не обрабатываем событие
      }
      var point = {
        x: event.point.x,
        y: event.point.y
      };
      var snappedPoint = snapToGrid(point, gridStepPixels);
      if (selectedTool === 'line') {
        if (!currentLineStart) {
          setCurrentLineStart(snappedPoint);
          setIsDrawing(true);
        } else {
          var endPoint = orthogonalSnap ? snapToOrthogonal(currentLineStart, snappedPoint) : snappedPoint;
          var finalEndPoint = snapToGrid(endPoint, gridStepPixels);
          addElement({
            type: 'line',
            start: currentLineStart,
            end: finalEndPoint,
            length: distance(currentLineStart, finalEndPoint)
          });
          setCurrentLineStart(finalEndPoint);
          setIsDrawing(true);
        }
      } else if (selectedTool === 'select') {
        // Сначала проверяем, кликнули ли на точку выбранной линии
        var clickedPointInfo = null;
        var _iterator = _createForOfIteratorHelper(selectedElements),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var selectedEl = _step.value;
            if (selectedEl.type === 'line') {
              var distToStart = distance(point, selectedEl.start);
              var distToEnd = distance(point, selectedEl.end);
              var pointThreshold = 8; // Радиус клика на точку

              if (distToStart < pointThreshold) {
                clickedPointInfo = {
                  elementId: selectedEl.id,
                  pointType: 'start',
                  point: selectedEl.start
                };
                break;
              } else if (distToEnd < pointThreshold) {
                clickedPointInfo = {
                  elementId: selectedEl.id,
                  pointType: 'end',
                  point: selectedEl.end
                };
                break;
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (clickedPointInfo) {
          // Находим все связанные точки
          var connectedPoints = findConnectedPoints(clickedPointInfo.elementId, clickedPointInfo.pointType, clickedPointInfo.point, elements, selectedElements);
          // Начинаем перетаскивание всех связанных точек
          setDraggingPoint(connectedPoints);
        } else {
          // Проверяем, кликнули ли на элемент
          // Сначала проверяем fillet (чтобы при клике на дугу выбирался fillet, а не линия)
          var clickedElement = elements.find(function (el) {
            if (el.type === 'fillet') {
              // Проверяем, находится ли точка на дуге fillet
              var distToArcCenter = distance(point, el.arc.center);
              var onArc = Math.abs(distToArcCenter - el.arc.radius) < 10;
              return onArc;
            }
            return false;
          });

          // Если fillet не выбран, проверяем другие элементы
          if (!clickedElement) {
            clickedElement = elements.find(function (el) {
              if (el.type === 'line') {
                return isPointOnLine(point, el.start, el.end, 10);
              }
              if (el.type === 'arc') {
                var dist = distance(point, el.center);
                return Math.abs(dist - el.radius) < 10;
              }
              return false;
            });
          }
          if (clickedElement) {
            selectElement(clickedElement, true);
          } else {
            selectElement(null);
          }
        }
      } else if (selectedTool === 'delete') {
        var _clickedElement = elements.find(function (el) {
          if (el.type === 'line') {
            return isPointOnLine(point, el.start, el.end, 10);
          }
          if (el.type === 'arc') {
            var dist = distance(point, el.center);
            return Math.abs(dist - el.radius) < 10;
          }
          if (el.type === 'fillet') {
            // Проверяем, находится ли точка на дуге fillet
            var distToArcCenter = distance(point, el.arc.center);
            var onArc = Math.abs(distToArcCenter - el.arc.radius) < 10;
            // Также проверяем линии, входящие в fillet
            var line1 = elements.find(function (l) {
              return l.id === el.line1Id;
            });
            var line2 = elements.find(function (l) {
              return l.id === el.line2Id;
            });
            var onLine1 = line1 && line1.type === 'line' ? isPointOnLine(point, line1.start, line1.end, 10) : false;
            var onLine2 = line2 && line2.type === 'line' ? isPointOnLine(point, line2.start, line2.end, 10) : false;
            return onLine1 || onLine2 || onArc;
          }
          if (el.type === 'chamfer') {
            // Проверяем, находится ли точка на линии chamfer
            var onChamfer = isPointOnLine(point, el.start, el.end, 10);
            // Также проверяем линии, входящие в chamfer
            var _line = elements.find(function (l) {
              return l.id === el.line1Id;
            });
            var _line2 = elements.find(function (l) {
              return l.id === el.line2Id;
            });
            var _onLine = _line && _line.type === 'line' ? isPointOnLine(point, _line.start, _line.end, 10) : false;
            var _onLine2 = _line2 && _line2.type === 'line' ? isPointOnLine(point, _line2.start, _line2.end, 10) : false;
            return _onLine || _onLine2 || onChamfer;
          }
          return false;
        });
        if (_clickedElement) {
          deleteElement(_clickedElement.id);
        } else if (selectedElements.length > 0) {
          deleteSelectedElements();
        }
      } else if (selectedTool === 'arc' || selectedTool === 'chamfer') {
        // В режиме arc можно редактировать только радиусы (fillet и arc элементы)
        // В режиме chamfer можно редактировать только фаски (chamfer элементы)
        // При клике на точку соединения создается радиус/фаска между двумя линиями

        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            location: 'CanvasEditor.jsx:320',
            message: 'arc mode click',
            data: {
              point: {
                x: point.x,
                y: point.y
              }
            },
            timestamp: Date.now(),
            sessionId: 'debug-session',
            runId: 'click-debug',
            hypothesisId: 'A'
          })
        })["catch"](function () {});
        // #endregion

        // Сначала проверяем, кликнули ли на fillet, arc или chamfer элемент для редактирования
        var clickedFillet = elements.find(function (el) {
          if (el.type === 'fillet') {
            // Проверяем, находится ли точка на дуге fillet
            var distToArcCenter = distance(point, el.arc.center);
            return Math.abs(distToArcCenter - el.arc.radius) < 10;
          }
          return false;
        });
        var clickedArc = elements.find(function (el) {
          if (el.type === 'arc') {
            var dist = distance(point, el.center);
            return Math.abs(dist - el.radius) < 10;
          }
          return false;
        });
        var clickedChamfer = elements.find(function (el) {
          if (el.type === 'chamfer') {
            // Проверяем, находится ли точка на линии chamfer
            return isPointOnLine(point, el.start, el.end, 10);
          }
          return false;
        });

        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            location: 'CanvasEditor.jsx:342',
            message: 'fillet/arc check',
            data: {
              clickedFillet: !!clickedFillet,
              clickedArc: !!clickedArc
            },
            timestamp: Date.now(),
            sessionId: 'debug-session',
            runId: 'click-debug',
            hypothesisId: 'B'
          })
        })["catch"](function () {});
        // #endregion

        if (clickedFillet) {
          // Выбираем fillet элемент для редактирования
          selectElement(clickedFillet);
        } else if (clickedArc) {
          // Выбираем arc элемент для редактирования
          selectElement(clickedArc);
        } else if (clickedChamfer) {
          // Выбираем chamfer элемент для редактирования
          selectElement(clickedChamfer);
        } else {
          // Проверяем клик на точку соединения
          var connectionPoints = findAllConnectionPoints(elements);
          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              location: 'CanvasEditor.jsx:349',
              message: 'checking connection points',
              data: {
                connectionPointsCount: connectionPoints.length,
                connectionPoints: connectionPoints.map(function (cp) {
                  return {
                    point: {
                      x: cp.point.x,
                      y: cp.point.y
                    },
                    line1Id: cp.line1.id,
                    line2Id: cp.line2.id
                  };
                })
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'click-debug',
              hypothesisId: 'A'
            })
          })["catch"](function () {});
          // #endregion
          var clickedConnection = connectionPoints.find(function (cp) {
            var dist = distance(point, cp.point);
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                location: 'CanvasEditor.jsx:352',
                message: 'distance check',
                data: {
                  clickPoint: {
                    x: point.x,
                    y: point.y
                  },
                  cpPoint: {
                    x: cp.point.x,
                    y: cp.point.y
                  },
                  dist: dist,
                  threshold: 10,
                  withinRange: dist < 10
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'click-debug',
                hypothesisId: 'A'
              })
            })["catch"](function () {});
            // #endregion
            return dist < 10; // Радиус клика на точку соединения
          });

          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              location: 'CanvasEditor.jsx:356',
              message: 'connection point click result',
              data: {
                clickedConnection: !!clickedConnection,
                clickedConnectionData: clickedConnection ? {
                  point: {
                    x: clickedConnection.point.x,
                    y: clickedConnection.point.y
                  },
                  line1Id: clickedConnection.line1.id,
                  line2Id: clickedConnection.line2.id
                } : null
              },
              timestamp: Date.now(),
              sessionId: 'debug-session',
              runId: 'click-debug',
              hypothesisId: 'A'
            })
          })["catch"](function () {});
          // #endregion

          if (clickedConnection) {
            // Кликнули на точку соединения - создаем радиус между двумя линиями
            var currentState = useEditorStore.getState();
            var line1FromStore = currentState.elements.find(function (el) {
              return el.id === clickedConnection.line1.id;
            });
            var line2FromStore = currentState.elements.find(function (el) {
              return el.id === clickedConnection.line2.id;
            });

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                location: 'CanvasEditor.jsx:362',
                message: 'before createFilletAtCorner',
                data: {
                  line1FromStore: !!line1FromStore,
                  line2FromStore: !!line2FromStore,
                  line1Id: clickedConnection.line1.id,
                  line2Id: clickedConnection.line2.id
                },
                timestamp: Date.now(),
                sessionId: 'debug-session',
                runId: 'click-debug',
                hypothesisId: 'B'
              })
            })["catch"](function () {});
            // #endregion

            if (line1FromStore && line2FromStore && line1FromStore.type === 'line' && line2FromStore.type === 'line') {
              if (selectedTool === 'arc') {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    location: 'CanvasEditor.jsx:363',
                    message: 'calling createFilletAtCorner',
                    data: {
                      line1Id: line1FromStore.id,
                      line2Id: line2FromStore.id
                    },
                    timestamp: Date.now(),
                    sessionId: 'debug-session',
                    runId: 'click-debug',
                    hypothesisId: 'B'
                  })
                })["catch"](function () {});
                // #endregion
                try {
                  createFilletAtCorner(line1FromStore, line2FromStore);
                  // #region agent log
                  fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                      location: 'CanvasEditor.jsx:363',
                      message: 'createFilletAtCorner completed',
                      data: {},
                      timestamp: Date.now(),
                      sessionId: 'debug-session',
                      runId: 'click-debug',
                      hypothesisId: 'B'
                    })
                  })["catch"](function () {});
                  // #endregion
                } catch (error) {
                  // #region agent log
                  fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                      location: 'CanvasEditor.jsx:363',
                      message: 'createFilletAtCorner error',
                      data: {
                        error: error.message,
                        stack: error.stack
                      },
                      timestamp: Date.now(),
                      sessionId: 'debug-session',
                      runId: 'click-debug',
                      hypothesisId: 'B'
                    })
                  })["catch"](function () {});
                  // #endregion
                }
              } else if (selectedTool === 'chamfer') {
                try {
                  createChamferAtCorner(line1FromStore, line2FromStore);
                } catch (error) {
                  console.error('Error creating chamfer:', error);
                }
              }
              selectElement(null);
            }
          } else {
            // Клик не на радиус и не на точку соединения - снимаем выделение
            selectElement(null);
          }
        }
      }
    };
    tool.onMouseMove = function (event) {
      // Получаем текущую позицию мыши и привязываем к сетке
      var point = {
        x: event.point.x,
        y: event.point.y
      };
      var snappedPoint = snapToGrid(point, gridStepPixels);

      // Определяем элемент под курсором в режиме select/edit
      var hoveredElement = null;
      var hoveredPointInfo = null;
      if (selectedTool === 'select') {
        // Сначала проверяем, находится ли курсор над точкой выбранной линии
        var _iterator2 = _createForOfIteratorHelper(selectedElements),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var selectedEl = _step2.value;
            if (selectedEl.type === 'line') {
              var distToStart = distance(point, selectedEl.start);
              var distToEnd = distance(point, selectedEl.end);
              var pointThreshold = 8;
              if (distToStart < pointThreshold) {
                hoveredPointInfo = {
                  elementId: selectedEl.id,
                  pointType: 'start'
                };
                // Меняем курсор на pointer
                if (canvasRef.current) {
                  canvasRef.current.style.cursor = 'pointer';
                }
                break;
              } else if (distToEnd < pointThreshold) {
                hoveredPointInfo = {
                  elementId: selectedEl.id,
                  pointType: 'end'
                };
                // Меняем курсор на pointer
                if (canvasRef.current) {
                  canvasRef.current.style.cursor = 'pointer';
                }
                break;
              }
            }
          }

          // Если не над точкой, проверяем элементы
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (!hoveredPointInfo) {
          hoveredElement = elements.find(function (el) {
            if (el.type === 'line') {
              return isPointOnLine(point, el.start, el.end, 10);
            }
            if (el.type === 'arc') {
              var dist = distance(point, el.center);
              return Math.abs(dist - el.radius) < 10;
            }
            if (el.type === 'fillet') {
              // Проверяем, находится ли точка на дуге fillet
              var distToArcCenter = distance(point, el.arc.center);
              var onArc = Math.abs(distToArcCenter - el.arc.radius) < 10;
              // Также проверяем линии, входящие в fillet
              var line1 = elements.find(function (l) {
                return l.id === el.line1Id;
              });
              var line2 = elements.find(function (l) {
                return l.id === el.line2Id;
              });
              var onLine1 = line1 && line1.type === 'line' ? isPointOnLine(point, line1.start, line1.end, 10) : false;
              var onLine2 = line2 && line2.type === 'line' ? isPointOnLine(point, line2.start, line2.end, 10) : false;
              return onLine1 || onLine2 || onArc;
            }
            return false;
          });

          // Возвращаем курсор к default, если не над точкой
          if (canvasRef.current && !hoveredElement) {
            canvasRef.current.style.cursor = 'default';
          }
        }
      } else if (selectedTool === 'arc') {
        // В режиме arc подсвечиваем только радиусы (fillet и arc элементы) для редактирования
        // Точки соединений отображаются и подсвечиваются отдельно
        hoveredElement = elements.find(function (el) {
          if (el.type === 'fillet') {
            // Проверяем, находится ли точка на дуге fillet
            var distToArcCenter = distance(point, el.arc.center);
            return Math.abs(distToArcCenter - el.arc.radius) < 10;
          }
          if (el.type === 'arc') {
            var dist = distance(point, el.center);
            return Math.abs(dist - el.radius) < 10;
          }
          return false;
        });
      } else if (selectedTool === 'chamfer') {
        // В режиме chamfer подсвечиваем только фаски (chamfer элементы) для редактирования
        // Точки соединений отображаются и подсвечиваются отдельно
        hoveredElement = elements.find(function (el) {
          if (el.type === 'chamfer') {
            // Проверяем, находится ли точка на линии chamfer
            return isPointOnLine(point, el.start, el.end, 10);
          }
          return false;
        });
      } else if (selectedTool === 'delete') {
        // В режиме delete находим элемент под курсором для подсветки красным
        hoveredElement = elements.find(function (el) {
          if (el.type === 'line') {
            return isPointOnLine(point, el.start, el.end, 10);
          }
          if (el.type === 'arc') {
            var dist = distance(point, el.center);
            return Math.abs(dist - el.radius) < 10;
          }
          if (el.type === 'fillet') {
            // Проверяем, находится ли точка на дуге fillet
            var distToArcCenter = distance(point, el.arc.center);
            var onArc = Math.abs(distToArcCenter - el.arc.radius) < 10;
            // Также проверяем линии, входящие в fillet
            var line1 = elements.find(function (l) {
              return l.id === el.line1Id;
            });
            var line2 = elements.find(function (l) {
              return l.id === el.line2Id;
            });
            var onLine1 = line1 && line1.type === 'line' ? isPointOnLine(point, line1.start, line1.end, 10) : false;
            var onLine2 = line2 && line2.type === 'line' ? isPointOnLine(point, line2.start, line2.end, 10) : false;
            return onLine1 || onLine2 || onArc;
          }
          if (el.type === 'chamfer') {
            // Проверяем, находится ли точка на линии chamfer
            var onChamfer = isPointOnLine(point, el.start, el.end, 10);
            // Также проверяем линии, входящие в chamfer
            var _line3 = elements.find(function (l) {
              return l.id === el.line1Id;
            });
            var _line4 = elements.find(function (l) {
              return l.id === el.line2Id;
            });
            var _onLine3 = _line3 && _line3.type === 'line' ? isPointOnLine(point, _line3.start, _line3.end, 10) : false;
            var _onLine4 = _line4 && _line4.type === 'line' ? isPointOnLine(point, _line4.start, _line4.end, 10) : false;
            return _onLine3 || _onLine4 || onChamfer;
          }
          return false;
        });

        // Меняем курсор на "not-allowed" (терка) если элемент найден
        if (canvasRef.current) {
          canvasRef.current.style.cursor = hoveredElement ? 'not-allowed' : 'default';
        }
      }
      setHoveredPoint(hoveredPointInfo);

      // Перерисовываем canvas
      scope.project.clear();

      // Отрисовываем сетку
      if (grid.visible) {
        drawGrid(scope, gridStepPixels, false);
      }

      // Находим все fillet и chamfer для проверки выделения линий
      var fillets = elements.filter(function (el) {
        return el.type === 'fillet';
      });
      var chamfers = elements.filter(function (el) {
        return el.type === 'chamfer';
      });
      var lineIdsInSelectedFillets = new Set();
      var lineIdsInSelectedChamfers = new Set();
      selectedElements.forEach(function (sel) {
        if (sel.type === 'fillet') {
          if (sel.line1Id) lineIdsInSelectedFillets.add(sel.line1Id);
          if (sel.line2Id) lineIdsInSelectedFillets.add(sel.line2Id);
        }
        if (sel.type === 'chamfer') {
          if (sel.line1Id) lineIdsInSelectedChamfers.add(sel.line1Id);
          if (sel.line2Id) lineIdsInSelectedChamfers.add(sel.line2Id);
        }
      });

      // Присваиваем номера концам линий для визуализации
      var pointNumberMap = assignPointNumbers(elements);

      // Отрисовываем элементы
      elements.forEach(function (element) {
        var isSelected = selectedElements.some(function (sel) {
          return sel.id === element.id;
        });
        var isHovered = hoveredElement && hoveredElement.id === element.id;
        var isDeleteHovered = selectedTool === 'delete' && isHovered;
        if (element.type === 'line') {
          // Если линия входит в выбранный fillet или chamfer, выделяем её
          var shouldHighlight = lineIdsInSelectedFillets.has(element.id) || lineIdsInSelectedChamfers.has(element.id);
          drawLine(scope, element, isSelected || shouldHighlight, isHovered && selectedTool !== 'delete', hoveredPointInfo, pointNumberMap, isDeleteHovered);
        } else if (element.type === 'arc') {
          drawArc(scope, element, isSelected, isHovered && selectedTool !== 'delete', isDeleteHovered);
        } else if (element.type === 'fillet') {
          drawFillet(scope, element, isSelected || hoveredElement && hoveredElement.id === element.id && selectedTool !== 'delete', elements, pointNumberMap, isDeleteHovered);
        } else if (element.type === 'chamfer') {
          drawChamfer(scope, element, isSelected || hoveredElement && hoveredElement.id === element.id && selectedTool !== 'delete', elements, pointNumberMap, isDeleteHovered);
        }
      });

      // В режиме "Скругление" или "Фаска" отображаем все точки соединений между линиями
      if (selectedTool === 'arc' || selectedTool === 'chamfer') {
        var connectionPoints = findAllConnectionPoints(elements);
        connectionPoints.forEach(function (cp, index) {
          var circle = new paper.Path.Circle({
            center: [cp.point.x, cp.point.y],
            radius: 2.6,
            fillColor: '#ff6600',
            strokeColor: '#fff',
            strokeWidth: 2
          });
          circle.data = {
            type: 'connectionPoint',
            connectionPoint: cp,
            index: index
          };
          // Перемещаем на передний план, чтобы точка была видна
          circle.bringToFront();
        });
      }

      // Точка-курсор отображается в режиме рисования линий
      if (selectedTool === 'line') {
        var displayPoint = snappedPoint;

        // Если уже есть начальная точка - показываем точку с учетом ортогональной привязки
        if (currentLineStart) {
          setIsDrawing(true);
          var endPoint = orthogonalSnap ? snapToOrthogonal(currentLineStart, snappedPoint) : snappedPoint;
          displayPoint = snapToGrid(endPoint, gridStepPixels);
          var tempLine = new paper.Path.Line({
            from: [currentLineStart.x, currentLineStart.y],
            to: [displayPoint.x, displayPoint.y],
            strokeColor: '#999',
            strokeWidth: 2
          });
          var length = distance(currentLineStart, displayPoint);
          var lengthText = formatLengthMM(length);
          var midX = (currentLineStart.x + displayPoint.x) / 2;
          var midY = (currentLineStart.y + displayPoint.y) / 2;

          // Используем тот же формат и стиль, что и финальная сноска
          var leaderLength = 15;
          var horizontalLength = 40;
          var angle = 45;
          var angleRad = angle * Math.PI / 180;
          var leaderStartX = midX;
          var leaderStartY = midY;
          var leaderEndX = midX + Math.cos(angleRad) * leaderLength;
          var leaderEndY = midY - Math.sin(angleRad) * leaderLength;
          var horizontalStartX = leaderEndX;
          var horizontalStartY = leaderEndY;
          var horizontalEndX = leaderEndX + horizontalLength;
          var horizontalEndY = leaderEndY;
          var textY = horizontalStartY - 3;
          var strokeColor = '#999'; // Тот же цвет, что и для невыбранных элементов
          var lineWidth = 0.5;

          // Определяем, является ли линия вертикальной
          var isVertical = Math.abs(currentLineStart.x - displayPoint.x) < 0.1;

          // Косая линия (как в финальной сноске)
          var tempLeaderLine = new paper.Path.Line({
            from: [leaderStartX, leaderStartY],
            to: [leaderEndX, leaderEndY],
            strokeColor: strokeColor,
            strokeWidth: lineWidth
          });

          // Горизонтальная линия (как в финальной сноске)
          var tempHorizontalLine = new paper.Path.Line({
            from: [horizontalStartX, horizontalStartY],
            to: [horizontalEndX, horizontalEndY],
            strokeColor: strokeColor,
            strokeWidth: lineWidth
          });

          // Создаем текст временно для получения его ширины
          var tempTextForBounds = new paper.PointText({
            point: [0, 0],
            content: lengthText,
            fillColor: strokeColor,
            fontSize: 11
          });
          var textWidth = tempTextForBounds.bounds.width;
          tempTextForBounds.remove(); // Удаляем временный текст

          // Выравниваем текст по правому краю сноски (horizontalEndX)
          var tempTextX = horizontalEndX - textWidth;
          // Для всех линий используем textY, чтобы текст был над сноской

          // Текст (как в финальной сноске) - выровнен по правому краю сноски
          var tempText = new paper.PointText({
            point: [tempTextX, textY],
            content: lengthText,
            fillColor: strokeColor,
            fontSize: 11
          });
        }

        // Отрисовываем точку-курсор с привязкой к сетке
        var cursorPoint = new paper.Path.Circle({
          center: [displayPoint.x, displayPoint.y],
          radius: 2.6,
          // Увеличено в два раза (было 1.3)
          fillColor: '#0066cc',
          strokeColor: '#ffffff',
          strokeWidth: 0.5
        });
      }
      scope.view.draw();
    };
    tool.onMouseDrag = function (event) {
      // Получаем актуальное состояние из store
      var currentState = useEditorStore.getState();
      if (draggingPoint && Array.isArray(draggingPoint) && draggingPoint.length > 0 && currentState.selectedTool === 'select') {
        var point = {
          x: event.point.x,
          y: event.point.y
        };

        // Обрабатываем первую точку для определения нового положения
        var firstPoint = draggingPoint[0];
        var firstElement = currentState.elements.find(function (el) {
          return el.id === firstPoint.elementId;
        });
        if (firstElement && firstElement.type === 'line') {
          var finalPoint;
          if (draggingPoint.length === 1) {
            // Если только одна точка - ограничиваем движение по линии
            var dx = firstElement.end.x - firstElement.start.x;
            var dy = firstElement.end.y - firstElement.start.y;
            var lineLength = Math.sqrt(dx * dx + dy * dy);
            if (lineLength > 0) {
              // Нормализованный вектор направления
              var dirX = dx / lineLength;
              var dirY = dy / lineLength;

              // Проецируем точку на линию
              var basePoint = firstPoint.pointType === 'start' ? firstElement.start : firstElement.end;
              var toPoint = {
                x: point.x - basePoint.x,
                y: point.y - basePoint.y
              };
              var projection = toPoint.x * dirX + toPoint.y * dirY;
              var newPoint = {
                x: basePoint.x + projection * dirX,
                y: basePoint.y + projection * dirY
              };

              // Привязываем к сетке
              finalPoint = snapToGrid(newPoint, gridStepPixels);
            } else {
              finalPoint = snapToGrid(point, gridStepPixels);
            }
          } else {
            // Если несколько точек - свободное движение
            finalPoint = snapToGrid(point, gridStepPixels);
          }

          // Обновляем все связанные точки
          draggingPoint.forEach(function (pointInfo) {
            var element = currentState.elements.find(function (el) {
              return el.id === pointInfo.elementId;
            });
            if (element && element.type === 'line') {
              if (pointInfo.pointType === 'start') {
                currentState.updateElement(element.id, {
                  start: finalPoint,
                  length: distance(finalPoint, element.end)
                });
              } else {
                currentState.updateElement(element.id, {
                  end: finalPoint,
                  length: distance(element.start, finalPoint)
                });
              }
            }
          });

          // Получаем актуальное состояние после обновления и перерисовываем canvas
          var updatedState = useEditorStore.getState();
          scope.project.clear();
          if (updatedState.grid.visible) {
            drawGrid(scope, gridStepPixels, false);
          }

          // Находим fillet и chamfer для выделения линий
          var fillets = updatedState.elements.filter(function (e) {
            return e.type === 'fillet';
          });
          var chamfers = updatedState.elements.filter(function (e) {
            return e.type === 'chamfer';
          });
          var lineIdsInSelectedFillets = new Set();
          var lineIdsInSelectedChamfers = new Set();
          updatedState.selectedElements.forEach(function (sel) {
            if (sel.type === 'fillet') {
              if (sel.line1Id) lineIdsInSelectedFillets.add(sel.line1Id);
              if (sel.line2Id) lineIdsInSelectedFillets.add(sel.line2Id);
            }
            if (sel.type === 'chamfer') {
              if (sel.line1Id) lineIdsInSelectedChamfers.add(sel.line1Id);
              if (sel.line2Id) lineIdsInSelectedChamfers.add(sel.line2Id);
            }
          });
          var pointNumberMap = assignPointNumbers(updatedState.elements);
          updatedState.elements.forEach(function (el) {
            var isSelected = updatedState.selectedElements.some(function (sel) {
              return sel.id === el.id;
            });
            if (el.type === 'line') {
              var shouldHighlight = lineIdsInSelectedFillets.has(el.id) || lineIdsInSelectedChamfers.has(el.id);
              drawLine(scope, el, isSelected || shouldHighlight, false, null, pointNumberMap);
            } else if (el.type === 'arc') {
              drawArc(scope, el, isSelected, false);
            } else if (el.type === 'fillet') {
              drawFillet(scope, el, isSelected, updatedState.elements, pointNumberMap);
            } else if (el.type === 'chamfer') {
              drawChamfer(scope, el, isSelected, updatedState.elements, pointNumberMap);
            }
          });
          scope.view.draw();
        }
      }
    };
    tool.onMouseUp = function (event) {
      setDraggingPoint(function (currentDragging) {
        if (currentDragging) {
          return null;
        }
        return currentDragging;
      });
    };
    tool.activate();
    tool.activate();
    return function () {
      tool.remove();
    };
  }, [selectedTool, currentLineStart, isDrawing, elements, selectedElements, gridStepPixels, paperProject, grid, dimensionsVisible, debugNumbersVisible, orthogonalSnap, addElement, selectElement, deleteElement, deleteSelectedElements, setIsDrawing, setCurrentLineStart, draggingPoint, updateElement, hoveredPoint]);

  // Обработка клавиши Escape для отмены рисования
  (0,external_React_.useEffect)(function () {
    var handleKeyDown = function handleKeyDown(e) {
      if (e.key === 'Escape' && isDrawing) {
        setCurrentLineStart(null);
        setIsDrawing(false);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return function () {
      return window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isDrawing]);

  // Обработка выхода мыши из области canvas
  (0,external_React_.useEffect)(function () {
    var canvas = canvasRef.current;
    if (!canvas) return;
    var handleMouseLeave = function handleMouseLeave() {
      setHoveredPoint(null);
      canvas.style.cursor = 'default';
    };
    canvas.addEventListener('mouseleave', handleMouseLeave);
    return function () {
      canvas.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, []);

  // Функции отрисовки
  var drawGrid = function drawGrid(scope, stepPixels, showMajorLines) {
    var view = scope.view;
    // Используем фактические размеры view или размеры контейнера
    var width = view.viewSize.width || containerSize.width || viewbox.width;
    var height = view.viewSize.height || containerSize.height || viewbox.height;
    var gridLayer = new paper.Layer();
    gridLayer.name = 'grid';

    // Обычные линии сетки
    for (var x = 0; x <= width; x += stepPixels) {
      var line = new paper.Path.Line({
        from: [x, 0],
        to: [x, height],
        strokeColor: '#e0e0e0',
        strokeWidth: 0.5
      });
      gridLayer.addChild(line);
    }
    for (var y = 0; y <= height; y += stepPixels) {
      var _line5 = new paper.Path.Line({
        from: [0, y],
        to: [width, y],
        strokeColor: '#e0e0e0',
        strokeWidth: 0.5
      });
      gridLayer.addChild(_line5);
    }

    // Темные линии через 10 мм
    if (showMajorLines) {
      var majorStepPixels = mmToPixels(10);
      for (var _x = 0; _x <= width; _x += majorStepPixels) {
        var _line6 = new paper.Path.Line({
          from: [_x, 0],
          to: [_x, height],
          strokeColor: '#999',
          strokeWidth: 1
        });
        gridLayer.addChild(_line6);
      }
      for (var _y = 0; _y <= height; _y += majorStepPixels) {
        var _line7 = new paper.Path.Line({
          from: [0, _y],
          to: [width, _y],
          strokeColor: '#999',
          strokeWidth: 1
        });
        gridLayer.addChild(_line7);
      }
    }
    gridLayer.locked = true;
  };

  // Функция для поиска всех точек, связанных с указанной точкой элемента
  var findConnectedPoints = function findConnectedPoints(elementId, pointType, point, allElements, selectedElements) {
    var tolerance = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var connectedPoints = [{
      elementId: elementId,
      pointType: pointType
    }];
    var clickedElement = allElements.find(function (el) {
      return el.id === elementId;
    });
    if (!clickedElement || clickedElement.type !== 'line') return connectedPoints;
    var clickedPoint = clickedElement[pointType]; // Используем точку из элемента

    // Ищем другие выбранные элементы с общей точкой
    var _iterator3 = _createForOfIteratorHelper(selectedElements),
      _step3;
    try {
      var _loop = function _loop() {
        var selectedEl = _step3.value;
        if (selectedEl.id === elementId || selectedEl.type !== 'line') return 1; // continue

        // Проверяем начало линии
        if (distance(clickedPoint, selectedEl.start) < tolerance) {
          // Проверяем, не добавили ли мы уже эту точку
          var alreadyAdded = connectedPoints.some(function (p) {
            return p.elementId === selectedEl.id && p.pointType === 'start';
          });
          if (!alreadyAdded) {
            connectedPoints.push({
              elementId: selectedEl.id,
              pointType: 'start'
            });
          }
        }
        // Проверяем конец линии
        if (distance(clickedPoint, selectedEl.end) < tolerance) {
          // Проверяем, не добавили ли мы уже эту точку
          var _alreadyAdded = connectedPoints.some(function (p) {
            return p.elementId === selectedEl.id && p.pointType === 'end';
          });
          if (!_alreadyAdded) {
            connectedPoints.push({
              elementId: selectedEl.id,
              pointType: 'end'
            });
          }
        }
      };
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        if (_loop()) continue;
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return connectedPoints;
  };

  // Функция для поиска всех точек соединений между линиями
  var findAllConnectionPoints = function findAllConnectionPoints(allElements) {
    console.log('=== findAllConnectionPoints CALLED ===');
    var connectionPoints = [];
    var lineElements = allElements.filter(function (el) {
      return el.type === 'line';
    });
    var tolerance = 10;
    console.log('findAllConnectionPoints: looking for connections between', lineElements.length, 'lines');

    // Для каждой пары линий проверяем, соединяются ли они
    for (var i = 0; i < lineElements.length; i++) {
      var _loop2 = function _loop2() {
        var line1 = lineElements[i];
        var line2 = lineElements[j];

        // Проверяем, не существует ли уже радиус для этой пары
        var existingFillet = allElements.find(function (el) {
          return el.type === 'fillet' && (el.line1Id === line1.id && el.line2Id === line2.id || el.line1Id === line2.id && el.line2Id === line1.id);
        });
        if (existingFillet) return 1; // continue
        // Пропускаем, если радиус уже существует

        var connection = findConnectionPoint(line1, line2, tolerance);
        console.log('Checking connection between lines', line1.id, 'and', line2.id, ':', connection);
        if (connection) {
          console.log('Connection found!', connection);
          connectionPoints.push({
            point: connection,
            line1: line1,
            line2: line2
          });
        }
      };
      for (var j = i + 1; j < lineElements.length; j++) {
        if (_loop2()) continue;
      }
    }
    console.log('findAllConnectionPoints: found', connectionPoints.length, 'connection points');
    return connectionPoints;
  };

  // Функция для присвоения номеров концам линий
  var assignPointNumbers = function assignPointNumbers(allElements) {
    var pointNumberMap = new Map(); // Map: "elementId:start" -> number, "elementId:end" -> number
    var nextNumber = 1;
    var tolerance = 10;

    // Для каждой линии присваиваем номера концам
    var lineElements = allElements.filter(function (el) {
      return el.type === 'line';
    });

    // Для каждой линии создаем две точки
    var points = [];
    lineElements.forEach(function (line) {
      points.push({
        elementId: line.id,
        pointType: 'start',
        point: line.start,
        line: line
      });
      points.push({
        elementId: line.id,
        pointType: 'end',
        point: line.end,
        line: line
      });
    });

    // Находим соединенные точки (с одинаковыми координатами) и присваиваем им одинаковые номера
    var _loop3 = function _loop3() {
      var key = "".concat(points[i].elementId, ":").concat(points[i].pointType);
      if (pointNumberMap.has(key)) return 1; // continue
      // Уже присвоен номер

      // Ищем все точки, которые совпадают с этой точкой
      var connectedPoints = [points[i]];
      for (var j = i + 1; j < points.length; j++) {
        var dist = distance(points[i].point, points[j].point);
        if (dist < tolerance) {
          connectedPoints.push(points[j]);
        }
      }

      // Всем соединенным точкам присваиваем одинаковый номер
      var number = nextNumber++;
      connectedPoints.forEach(function (p) {
        var pKey = "".concat(p.elementId, ":").concat(p.pointType);
        pointNumberMap.set(pKey, number);
      });
    };
    for (var i = 0; i < points.length; i++) {
      if (_loop3()) continue;
    }
    return pointNumberMap;
  };
  var drawLine = function drawLine(scope, element, isSelected) {
    var isHovered = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var hoveredPointInfo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var pointNumberMap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var isDeleteHovered = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    // Приоритет: delete hovered (red) > selected > hovered > обычный
    var strokeColor = '#000';
    var strokeWidth = 2;
    if (isDeleteHovered) {
      strokeColor = '#ff0000';
      strokeWidth = 3;
    } else if (isSelected) {
      strokeColor = '#0073aa';
      strokeWidth = 3;
    } else if (isHovered) {
      strokeColor = '#0073aa';
      strokeWidth = 2;
    }
    var line = new paper.Path.Line({
      from: [element.start.x, element.start.y],
      to: [element.end.x, element.end.y],
      strokeColor: strokeColor,
      strokeWidth: strokeWidth
    });
    line.data = {
      elementId: element.id,
      type: 'line'
    };

    // Отрисовка точек на концах для выбранных линий
    if (isSelected && element.type === 'line') {
      var pointRadius = 2.6; // Такой же размер, как у точки-курсора при рисовании

      // Проверяем, находится ли курсор над начальной точкой
      var isStartHovered = hoveredPointInfo && hoveredPointInfo.elementId === element.id && hoveredPointInfo.pointType === 'start';

      // Проверяем, находится ли курсор над конечной точкой
      var isEndHovered = hoveredPointInfo && hoveredPointInfo.elementId === element.id && hoveredPointInfo.pointType === 'end';

      // Точка на начале линии (с изменением цвета при hover)
      var startPoint = new paper.Path.Circle({
        center: [element.start.x, element.start.y],
        radius: pointRadius,
        fillColor: isStartHovered ? '#ff8800' : '#0073aa',
        // Оранжевый при hover
        strokeColor: '#fff',
        strokeWidth: 2
      });
      startPoint.data = {
        elementId: element.id,
        pointType: 'start',
        type: 'linePoint'
      };

      // Точка на конце линии (с изменением цвета при hover)
      var endPoint = new paper.Path.Circle({
        center: [element.end.x, element.end.y],
        radius: pointRadius,
        fillColor: isEndHovered ? '#ff8800' : '#0073aa',
        // Оранжевый при hover
        strokeColor: '#fff',
        strokeWidth: 2
      });
      endPoint.data = {
        elementId: element.id,
        pointType: 'end',
        type: 'linePoint'
      };
    }

    // Отображаем номера концов линий (только если включена отладка)
    if (pointNumberMap && debugNumbersVisible) {
      var startKey = "".concat(element.id, ":start");
      var endKey = "".concat(element.id, ":end");
      var startNumber = pointNumberMap.get(startKey);
      var endNumber = pointNumberMap.get(endKey);
      if (startNumber !== undefined) {
        var text = new paper.PointText({
          point: [element.start.x + 8, element.start.y - 8],
          content: "".concat(startNumber),
          fillColor: '#ff0000',
          fontSize: 12,
          fontWeight: 'bold'
        });
      }
      if (endNumber !== undefined) {
        var _text = new paper.PointText({
          point: [element.end.x + 8, element.end.y - 8],
          content: "".concat(endNumber),
          fillColor: '#ff0000',
          fontSize: 12,
          fontWeight: 'bold'
        });
      }
    }

    // Отрисовка размеров (сноска)
    if (dimensionsVisible) {
      drawDimensionCallout(scope, element, isSelected || isHovered);
    }
  };
  var drawArc = function drawArc(scope, element, isSelected) {
    var isHovered = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var isDeleteHovered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var center = new paper.Point(element.center.x, element.center.y);
    var radius = element.radius;
    var startAngle = element.startAngle || 0;
    var angle = element.angle || 90;
    var startAngleRad = startAngle * Math.PI / 180;
    var endAngleRad = startAngleRad + angle * Math.PI / 180;
    var startPoint = new paper.Point(center.x + radius * Math.cos(startAngleRad), center.y + radius * Math.sin(startAngleRad));
    var endPoint = new paper.Point(center.x + radius * Math.cos(endAngleRad), center.y + radius * Math.sin(endAngleRad));
    var largeArcFlag = angle > 180 ? 1 : 0;

    // Создаем путь для дуги используя Paper.js Arc
    // Paper.js Arc создается через три точки: from, through, to
    // through - это точка на дуге между from и to
    var midAngle = startAngleRad + angle * Math.PI / 360;
    var throughPoint = new paper.Point(center.x + radius * Math.cos(midAngle), center.y + radius * Math.sin(midAngle));
    var path = new paper.Path.Arc({
      from: startPoint,
      through: throughPoint,
      to: endPoint
    });

    // Приоритет: delete hovered (red) > selected > hovered > обычный
    if (isDeleteHovered) {
      path.strokeColor = '#ff0000';
      path.strokeWidth = 3;
    } else if (isSelected) {
      path.strokeColor = '#0073aa';
      path.strokeWidth = 3;
    } else if (isHovered) {
      path.strokeColor = '#0073aa';
      path.strokeWidth = 2;
    } else {
      path.strokeColor = '#000';
      path.strokeWidth = 2;
    }
    path.data = {
      elementId: element.id,
      type: 'arc'
    };
  };
  var drawFillet = function drawFillet(scope, element) {
    var isSelected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var allElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : elements;
    var pointNumberMap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var isDeleteHovered = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    if (element.type !== 'fillet') return;

    // Приоритет: delete hovered (red) > selected > обычный
    var strokeColor = isDeleteHovered ? '#ff0000' : isSelected ? '#0073aa' : '#000';
    var strokeWidth = isDeleteHovered || isSelected ? 3 : 2;

    // Отрисовываем только дугу, линии отрисовываются отдельно как обычные элементы
    var arc = element.arc;
    // Используем сохраненные точки арки, если они есть, для гарантии правильной привязки к линиям
    // Fallback на пересчет из углов для обратной совместимости
    var startPoint, endPoint;

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1078',
        message: 'drawFillet checking saved points',
        data: {
          hasArcStartPoint: !!element.arcStartPoint,
          hasArcEndPoint: !!element.arcEndPoint,
          arcStartPoint: element.arcStartPoint,
          arcEndPoint: element.arcEndPoint
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'debug',
        hypothesisId: 'E'
      })
    })["catch"](function () {});
    // #endregion

    if (element.arcStartPoint && element.arcEndPoint) {
      // Используем сохраненные точки (они точно лежат на линиях)
      startPoint = new paper.Point(element.arcStartPoint.x, element.arcStartPoint.y);
      endPoint = new paper.Point(element.arcEndPoint.x, element.arcEndPoint.y);

      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          location: 'CanvasEditor.jsx:1081',
          message: 'drawFillet using saved points',
          data: {
            startPoint: {
              x: startPoint.x,
              y: startPoint.y
            },
            endPoint: {
              x: endPoint.x,
              y: endPoint.y
            }
          },
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'debug',
          hypothesisId: 'E'
        })
      })["catch"](function () {});
      // #endregion
    } else {
      // Fallback: вычисляем точки от центра с заданным радиусом и углами
      var _startAngleRad = arc.startAngle * Math.PI / 180;
      var _endAngleRad = _startAngleRad + arc.angle * Math.PI / 180;
      startPoint = new paper.Point(arc.center.x + arc.radius * Math.cos(_startAngleRad), arc.center.y + arc.radius * Math.sin(_startAngleRad));
      endPoint = new paper.Point(arc.center.x + arc.radius * Math.cos(_endAngleRad), arc.center.y + arc.radius * Math.sin(_endAngleRad));

      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          location: 'CanvasEditor.jsx:1094',
          message: 'drawFillet using calculated points',
          data: {
            startPoint: {
              x: startPoint.x,
              y: startPoint.y
            },
            endPoint: {
              x: endPoint.x,
              y: endPoint.y
            }
          },
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'debug',
          hypothesisId: 'E'
        })
      })["catch"](function () {});
      // #endregion
    }

    // Получаем обновленные координаты линий
    var line1 = allElements.find(function (el) {
      return el.id === element.line1Id;
    });
    var line2 = allElements.find(function (el) {
      return el.id === element.line2Id;
    });

    // #region agent log
    if (line1 && line2) {
      var line1EndPoint = line1.end;
      var line1StartPoint = line1.start;
      var line2EndPoint = line2.end;
      var line2StartPoint = line2.start;
      var distStartToLine1End = startPoint.getDistance(new paper.Point(line1EndPoint.x, line1EndPoint.y));
      var distStartToLine1Start = startPoint.getDistance(new paper.Point(line1StartPoint.x, line1StartPoint.y));
      var distEndToLine2End = endPoint.getDistance(new paper.Point(line2EndPoint.x, line2EndPoint.y));
      var distEndToLine2Start = endPoint.getDistance(new paper.Point(line2StartPoint.x, line2StartPoint.y));
      fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          location: 'CanvasEditor.jsx:890',
          message: 'drawFillet arc vs line points',
          data: {
            arcStartPoint: {
              x: startPoint.x,
              y: startPoint.y
            },
            arcEndPoint: {
              x: endPoint.x,
              y: endPoint.y
            },
            line1: {
              start: line1StartPoint,
              end: line1EndPoint
            },
            line2: {
              start: line2StartPoint,
              end: line2EndPoint
            },
            distStartToLine1End: distStartToLine1End,
            distStartToLine1Start: distStartToLine1Start,
            distEndToLine2End: distEndToLine2End,
            distEndToLine2Start: distEndToLine2Start,
            expectedArcStartPoint: element.arcStartPoint,
            expectedArcEndPoint: element.arcEndPoint
          },
          timestamp: Date.now(),
          sessionId: 'debug-session',
          runId: 'post-fix',
          hypothesisId: 'C'
        })
      })["catch"](function () {});
    }
    // #endregion

    // Строим дугу, начиная с startPoint и заканчивая endPoint, чтобы гарантировать правильную привязку к линиям
    // Используем сохраненные точки как начальную и конечную точки дуги
    var centerPoint = new paper.Point(arc.center.x, arc.center.y);

    // Вычисляем углы от центра к начальной и конечной точкам
    var startAngleRad = Math.atan2(startPoint.y - centerPoint.y, startPoint.x - centerPoint.x);
    var endAngleRad = Math.atan2(endPoint.y - centerPoint.y, endPoint.x - centerPoint.x);

    // Вычисляем разность углов и нормализуем к [-π, π]
    var angleDiff = endAngleRad - startAngleRad;
    if (angleDiff > Math.PI) {
      angleDiff -= 2 * Math.PI;
    } else if (angleDiff < -Math.PI) {
      angleDiff += 2 * Math.PI;
    }

    // Строим Path, начиная с сохраненной начальной точки
    var arcPath = new paper.Path();
    arcPath.add(startPoint); // Начинаем с сохраненной точки, которая точно лежит на линии

    // Добавляем промежуточные точки дуги между startPoint и endPoint
    var numSegments = Math.max(8, Math.ceil(Math.abs(angleDiff) * 180 / Math.PI / 5)); // Минимум 8 сегментов, или по 5 градусов на сегмент

    // Добавляем промежуточные точки (пропускаем первую точку, так как она уже добавлена)
    for (var i = 1; i < numSegments; i++) {
      var t = i / numSegments;
      var angle = startAngleRad + t * angleDiff;
      var point = new paper.Point(centerPoint.x + arc.radius * Math.cos(angle), centerPoint.y + arc.radius * Math.sin(angle));
      arcPath.add(point);
    }

    // Заканчиваем сохраненной конечной точкой, которая точно лежит на линии
    arcPath.add(endPoint);
    arcPath.strokeColor = strokeColor;
    arcPath.strokeWidth = strokeWidth;
    arcPath.data = {
      elementId: element.id,
      type: 'fillet-arc'
    };

    // Отображаем номера точек арки и их соответствие с концами линий (только если включена отладка)
    if (pointNumberMap && line1 && line2 && debugNumbersVisible) {
      // Определяем, к каким концам линий привязаны точки арки
      var _distStartToLine1End = startPoint.getDistance(new paper.Point(line1.end.x, line1.end.y));
      var _distStartToLine1Start = startPoint.getDistance(new paper.Point(line1.start.x, line1.start.y));
      var _distEndToLine2End = endPoint.getDistance(new paper.Point(line2.end.x, line2.end.y));
      var _distEndToLine2Start = endPoint.getDistance(new paper.Point(line2.start.x, line2.start.y));

      // Определяем, к какому концу line1 ближе arcStartPoint
      var line1PointType = _distStartToLine1End < _distStartToLine1Start ? 'end' : 'start';
      var line1Key = "".concat(line1.id, ":").concat(line1PointType);
      var line1PointNumber = pointNumberMap.get(line1Key);

      // Определяем, к какому концу line2 ближе arcEndPoint
      var line2PointType = _distEndToLine2End < _distEndToLine2Start ? 'end' : 'start';
      var line2Key = "".concat(line2.id, ":").concat(line2PointType);
      var line2PointNumber = pointNumberMap.get(line2Key);

      // Отображаем номер для arcStartPoint (соответствует концу line1)
      if (line1PointNumber !== undefined) {
        var text = new paper.PointText({
          point: [startPoint.x + 8, startPoint.y - 8],
          content: "A".concat(line1PointNumber),
          fillColor: '#00ff00',
          fontSize: 12,
          fontWeight: 'bold'
        });
      }

      // Отображаем номер для arcEndPoint (соответствует концу line2)
      if (line2PointNumber !== undefined) {
        var _text2 = new paper.PointText({
          point: [endPoint.x + 8, endPoint.y - 8],
          content: "A".concat(line2PointNumber),
          fillColor: '#00ff00',
          fontSize: 12,
          fontWeight: 'bold'
        });
      }
    }

    // Отрисовываем сноску с радиусом, если включено отображение размеров
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1244',
        message: 'before drawFilletDimensionCallout',
        data: {
          dimensionsVisible: dimensionsVisible,
          hasArcCenter: !!arc.center,
          arcCenter: arc.center,
          arcRadius: arc.radius
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'initial',
        hypothesisId: 'D'
      })
    })["catch"](function () {});
    // #endregion
    if (dimensionsVisible && arc.center) {
      drawFilletDimensionCallout(scope, element, isSelected, arc.center, arc.radius, pointNumberMap, allElements);
    }
  };
  var drawChamfer = function drawChamfer(scope, element) {
    var isSelected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var allElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : elements;
    var pointNumberMap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var isDeleteHovered = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    if (element.type !== 'chamfer') return;

    // Приоритет: delete hovered (red) > selected > обычный
    var strokeColor = isDeleteHovered ? '#ff0000' : isSelected ? '#0073aa' : '#000';
    var strokeWidth = isDeleteHovered || isSelected ? 3 : 2;

    // Отрисовываем прямую линию между точками обрезки
    var startPoint = new paper.Point(element.start.x, element.start.y);
    var endPoint = new paper.Point(element.end.x, element.end.y);
    var chamferLine = new paper.Path.Line({
      from: startPoint,
      to: endPoint,
      strokeColor: strokeColor,
      strokeWidth: strokeWidth
    });
    chamferLine.data = {
      elementId: element.id,
      type: 'chamfer-line'
    };

    // Отображаем номера точек, если включена отладка
    if (pointNumberMap && debugNumbersVisible) {
      var line1 = allElements.find(function (el) {
        return el.id === element.line1Id;
      });
      var line2 = allElements.find(function (el) {
        return el.id === element.line2Id;
      });
      if (line1 && line2) {
        var distStartToLine1End = startPoint.getDistance(new paper.Point(line1.end.x, line1.end.y));
        var distStartToLine1Start = startPoint.getDistance(new paper.Point(line1.start.x, line1.start.y));
        var distEndToLine2End = endPoint.getDistance(new paper.Point(line2.end.x, line2.end.y));
        var distEndToLine2Start = endPoint.getDistance(new paper.Point(line2.start.x, line2.start.y));
        var line1PointType = distStartToLine1End < distStartToLine1Start ? 'end' : 'start';
        var line1Key = "".concat(line1.id, ":").concat(line1PointType);
        var line1PointNumber = pointNumberMap.get(line1Key);
        var line2PointType = distEndToLine2End < distEndToLine2Start ? 'end' : 'start';
        var line2Key = "".concat(line2.id, ":").concat(line2PointType);
        var line2PointNumber = pointNumberMap.get(line2Key);
        if (line1PointNumber !== undefined) {
          new paper.PointText({
            point: [startPoint.x + 8, startPoint.y - 8],
            content: "C".concat(line1PointNumber),
            fillColor: '#00ff00',
            fontSize: 12,
            fontWeight: 'bold'
          });
        }
        if (line2PointNumber !== undefined) {
          new paper.PointText({
            point: [endPoint.x + 8, endPoint.y - 8],
            content: "C".concat(line2PointNumber),
            fillColor: '#00ff00',
            fontSize: 12,
            fontWeight: 'bold'
          });
        }
      }
    }

    // Отрисовываем сноску с глубиной, если включено отображение размеров
    if (dimensionsVisible) {
      var midPoint = {
        x: (element.start.x + element.end.x) / 2,
        y: (element.start.y + element.end.y) / 2
      };
      drawChamferDimensionCallout(scope, element, isSelected, midPoint, element.depth, pointNumberMap, allElements);
    }
  };
  var drawDimensionCallout = function drawDimensionCallout(scope, element, isSelected) {
    if (element.type !== 'line') return;
    var midX = (element.start.x + element.end.x) / 2;
    var midY = (element.start.y + element.end.y) / 2;
    var leaderLength = 15;
    var horizontalLength = 40;
    var angle = 45;
    var angleRad = angle * Math.PI / 180;
    var leaderStartX = midX;
    var leaderStartY = midY;
    var leaderEndX = midX + Math.cos(angleRad) * leaderLength;
    var leaderEndY = midY - Math.sin(angleRad) * leaderLength;
    var horizontalStartX = leaderEndX;
    var horizontalStartY = leaderEndY;
    var horizontalEndX = leaderEndX + horizontalLength;
    var horizontalEndY = leaderEndY;
    var textY = horizontalStartY - 3; // В половину меньше смещения (было -12, потом +5, теперь -3)

    var lengthText = formatLengthMM(element.length || distance(element.start, element.end));
    var strokeColor = isSelected ? '#0073aa' : '#999'; // Светлее для невыбранных
    var lineWidth = 0.5; // Тоньше (было 1)

    // Определяем, является ли линия вертикальной
    var isVertical = Math.abs(element.start.x - element.end.x) < 0.1;

    // Косая линия
    var leaderLine = new paper.Path.Line({
      from: [leaderStartX, leaderStartY],
      to: [leaderEndX, leaderEndY],
      strokeColor: strokeColor,
      strokeWidth: lineWidth
    });

    // Горизонтальная линия
    var horizontalLine = new paper.Path.Line({
      from: [horizontalStartX, horizontalStartY],
      to: [horizontalEndX, horizontalEndY],
      strokeColor: strokeColor,
      strokeWidth: lineWidth
    });

    // Создаем текст временно для получения его ширины
    var tempText = new paper.PointText({
      point: [0, 0],
      content: lengthText,
      fillColor: strokeColor,
      fontSize: 11
    });
    var textWidth = tempText.bounds.width;
    tempText.remove(); // Удаляем временный текст

    // Выравниваем текст по правому краю сноски (horizontalEndX)
    // В Paper.js точка позиционирования - это левый край текста, поэтому вычитаем ширину
    var textX = horizontalEndX - textWidth;
    // Для всех линий используем textY, чтобы текст был над сноской

    // Текст - выровнен по правому краю сноски
    var text = new paper.PointText({
      point: [textX, textY],
      content: lengthText,
      fillColor: strokeColor,
      fontSize: 11
    });
  };
  var drawFilletDimensionCallout = function drawFilletDimensionCallout(scope, element, isSelected, arcCenter, arcRadius) {
    var pointNumberMap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var allElements = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
    if (element.type !== 'fillet') return;

    // Определяем номера точек для анализа углов 6-7 и 14-15
    var line1PointNumber = null;
    var line2PointNumber = null;
    if (pointNumberMap && element.line1Id && element.line2Id) {
      var line1 = allElements.find(function (el) {
        return el.id === element.line1Id && el.type === 'line';
      });
      var line2 = allElements.find(function (el) {
        return el.id === element.line2Id && el.type === 'line';
      });
      if (line1 && line2 && element.arcStartPoint && element.arcEndPoint) {
        // Определяем, к каким концам линий привязаны точки арки
        var distStartToLine1End = distance(element.arcStartPoint, line1.end);
        var distStartToLine1Start = distance(element.arcStartPoint, line1.start);
        var distEndToLine2End = distance(element.arcEndPoint, line2.end);
        var distEndToLine2Start = distance(element.arcEndPoint, line2.start);
        var line1PointType = distStartToLine1End < distStartToLine1Start ? 'end' : 'start';
        var line1Key = "".concat(line1.id, ":").concat(line1PointType);
        line1PointNumber = pointNumberMap.get(line1Key);
        var line2PointType = distEndToLine2End < distEndToLine2Start ? 'end' : 'start';
        var line2Key = "".concat(line2.id, ":").concat(line2PointType);
        line2PointNumber = pointNumberMap.get(line2Key);
      }
    }

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1357',
        message: 'drawFilletDimensionCallout called',
        data: {
          arcCenter: arcCenter,
          arcRadius: arcRadius,
          line1PointNumber: line1PointNumber,
          line2PointNumber: line2PointNumber,
          isAngle6_7: line1PointNumber === 6 && line2PointNumber === 7 || line1PointNumber === 7 && line2PointNumber === 6,
          isAngle14_15: line1PointNumber === 14 && line2PointNumber === 15 || line1PointNumber === 15 && line2PointNumber === 14
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'analyze-angles',
        hypothesisId: 'A'
      })
    })["catch"](function () {});
    // #endregion

    var leaderLength = 15;
    var horizontalLength = 40;

    // Центр радиуса - это начальная точка отрисовки сноски
    var centerX = arcCenter.x;
    var centerY = arcCenter.y;

    // Вычисляем середину видимого отрезка радиуса (дуги)
    // Используем сохраненные точки начала и конца дуги для точного вычисления середины
    var arcPointX, arcPointY;
    if (element.arcStartPoint && element.arcEndPoint) {
      // Вычисляем среднюю точку между началом и концом дуги
      arcPointX = (element.arcStartPoint.x + element.arcEndPoint.x) / 2;
      arcPointY = (element.arcStartPoint.y + element.arcEndPoint.y) / 2;

      // Проектируем эту точку на дугу (на расстояние arcRadius от центра)
      var dx = arcPointX - centerX;
      var dy = arcPointY - centerY;
      var dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 0.0001) {
        // Нормализуем и масштабируем до радиуса
        arcPointX = centerX + dx / dist * arcRadius;
        arcPointY = centerY + dy / dist * arcRadius;
      }
    } else {
      // Fallback: используем средний угол дуги
      var arc = element.arc;
      var startAngleRad = arc.startAngle * Math.PI / 180;
      var angleRad = arc.angle * Math.PI / 180;
      var midAngleRad = startAngleRad + angleRad / 2;
      arcPointX = centerX + Math.cos(midAngleRad) * arcRadius;
      arcPointY = centerY + Math.sin(midAngleRad) * arcRadius;
    }

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1345',
        message: 'arc midpoint calculation',
        data: {
          arcCenter: {
            x: centerX,
            y: centerY
          },
          arcRadius: arcRadius,
          arcStartPoint: element.arcStartPoint,
          arcEndPoint: element.arcEndPoint,
          arcPoint: {
            x: arcPointX,
            y: arcPointY
          }
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'check-arc-midpoint',
        hypothesisId: 'F'
      })
    })["catch"](function () {});
    // #endregion

    // Первая линия: от центра радиуса до точки на дуге (проходит через середину видимого элемента)
    var leaderStartX = centerX;
    var leaderStartY = centerY;
    var leaderEndX = arcPointX;
    var leaderEndY = arcPointY;

    // Определяем направление "снаружи" угла
    // Используем сохраненные направления линий для вычисления биссектрисы
    var outsideDir;
    if (element.line1Direction && element.line2Direction) {
      // Вычисляем биссектрису (направлена внутрь угла)
      var bisectorUnnormalized = {
        x: element.line1Direction.x + element.line2Direction.x,
        y: element.line1Direction.y + element.line2Direction.y
      };
      var bisectorLength = Math.sqrt(bisectorUnnormalized.x * bisectorUnnormalized.x + bisectorUnnormalized.y * bisectorUnnormalized.y);
      var bisectorDir = bisectorLength > 0.0001 ? {
        x: bisectorUnnormalized.x / bisectorLength,
        y: bisectorUnnormalized.y / bisectorLength
      } : {
        x: -element.line1Direction.y,
        y: element.line1Direction.x
      };

      // Направление "снаружи" - противоположно биссектрисе
      outsideDir = {
        x: -bisectorDir.x,
        y: -bisectorDir.y
      };
    } else {
      // Fallback: используем направление от центра к точке на дуге, повернутое на 90 градусов
      var dirToArc = {
        x: arcPointX - centerX,
        y: arcPointY - centerY
      };
      var dirLength = Math.sqrt(dirToArc.x * dirToArc.x + dirToArc.y * dirToArc.y);
      if (dirLength > 0.0001) {
        var normalizedDir = {
          x: dirToArc.x / dirLength,
          y: dirToArc.y / dirLength
        };
        // Поворачиваем на 90 градусов против часовой стрелки для направления снаружи
        outsideDir = {
          x: -normalizedDir.y,
          y: normalizedDir.x
        };
      } else {
        // Последний fallback: фиксированное направление
        outsideDir = {
          x: Math.cos(45 * Math.PI / 180),
          y: -Math.sin(45 * Math.PI / 180)
        };
      }
    }

    // Косая линия: от точки на дуге в направлении "снаружи" угла
    var diagonalEndX = arcPointX + outsideDir.x * leaderLength;
    var diagonalEndY = arcPointY + outsideDir.y * leaderLength;

    // Горизонтальная линия: от конца косой линии
    var horizontalStartX = diagonalEndX;
    var horizontalStartY = diagonalEndY;
    var horizontalEndX = diagonalEndX + horizontalLength;
    var horizontalEndY = diagonalEndY;

    // Определяем, должен ли текст быть над линией на основе направления outsideDir
    // outsideDir - это направление "снаружи" угла, вычисленное из геометрии угла
    // Если outsideDir направлен вверх (y < 0), текст над линией
    // Если outsideDir направлен вниз (y > 0), текст под линией
    var textAboveLine = outsideDir.y < 0;

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1475',
        message: 'text placement analysis',
        data: {
          line1PointNumber: line1PointNumber,
          line2PointNumber: line2PointNumber,
          textAboveLine: textAboveLine,
          horizontalStartY: horizontalStartY,
          centerY: centerY,
          outsideDir: outsideDir,
          outsideDirY: outsideDir.y
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'analyze-angles',
        hypothesisId: 'B'
      })
    })["catch"](function () {});
    // #endregion

    // Позиция текста - над или под горизонтальной линией
    // Для текста над линией используем меньший отступ (-3 вместо -14), чтобы текст не был слишком высоко
    var textY = textAboveLine ? horizontalStartY - 3 // Отступ вверх от линии (3 пикселя для размещения текста над линией)
    : horizontalStartY + 14; // Отступ вниз от линии (14 пикселей для размещения текста под линией)

    var radiusText = 'R ' + formatLengthMM(arcRadius);
    var strokeColor = isSelected ? '#0073aa' : '#999';
    var lineWidth = 0.5;

    // Первая линия: от центра радиуса до точки на дуге
    var leaderLine = new paper.Path.Line({
      from: [leaderStartX, leaderStartY],
      to: [leaderEndX, leaderEndY],
      strokeColor: strokeColor,
      strokeWidth: lineWidth
    });

    // Косая линия: от точки на дуге под углом 45 градусов вправо-вверх
    var diagonalLine = new paper.Path.Line({
      from: [arcPointX, arcPointY],
      to: [diagonalEndX, diagonalEndY],
      strokeColor: strokeColor,
      strokeWidth: lineWidth
    });

    // Горизонтальная линия: от конца косой линии
    var horizontalLine = new paper.Path.Line({
      from: [horizontalStartX, horizontalStartY],
      to: [horizontalEndX, horizontalEndY],
      strokeColor: strokeColor,
      strokeWidth: lineWidth
    });

    // Создаем текст временно для получения его ширины
    var tempText = new paper.PointText({
      point: [0, 0],
      content: radiusText,
      fillColor: strokeColor,
      fontSize: 11
    });
    var textWidth = tempText.bounds.width;
    tempText.remove();

    // Выравниваем текст по правому краю горизонтальной линии
    var finalTextX = horizontalEndX - textWidth;

    // Текст - выровнен по правому краю горизонтальной линии
    var text = new paper.PointText({
      point: [finalTextX, textY],
      content: radiusText,
      fillColor: strokeColor,
      fontSize: 11
    });
  };

  // Создание скругления (fillet) между двумя линиями
  var createFilletAtCorner = function createFilletAtCorner(line1Param, line2Param) {
    // Получаем актуальные версии линий из store перед созданием fillet
    var currentState = useEditorStore.getState();
    var actualLine1 = currentState.elements.find(function (el) {
      return el.id === line1Param.id;
    });
    var actualLine2 = currentState.elements.find(function (el) {
      return el.id === line2Param.id;
    });
    if (!actualLine1 || !actualLine2 || actualLine1.type !== 'line' || actualLine2.type !== 'line') {
      return;
    }

    // Нормализуем порядок линий: всегда используем линию с меньшим ID как line1
    // Это гарантирует, что логика не зависит от порядка параметров
    var line1 = actualLine1.id < actualLine2.id ? actualLine1 : actualLine2;
    var line2 = actualLine1.id < actualLine2.id ? actualLine2 : actualLine1;

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1142',
        message: 'createFilletAtCorner entry with actual lines',
        data: {
          line1: {
            id: line1.id,
            start: line1.start,
            end: line1.end
          },
          line2: {
            id: line2.id,
            start: line2.start,
            end: line2.end
          }
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'initial',
        hypothesisId: 'C'
      })
    })["catch"](function () {});
    // #endregion
    var connection = findConnectionPoint(line1, line2, 10);
    if (!connection) {
      return;
    }

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:976',
        message: 'connection found',
        data: {
          connection: connection,
          line1End: connection.line1End,
          line2End: connection.line2End
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'post-fix',
        hypothesisId: 'A'
      })
    })["catch"](function () {});
    // #endregion

    var arcRadius = mmToPixels(3); // 3 мм по умолчанию

    // Определяем, какой конец каждой линии является точкой соединения
    var distToLine1Start = distance(connection, line1.start);
    var distToLine1End = distance(connection, line1.end);
    var distToLine2Start = distance(connection, line2.start);
    var distToLine2End = distance(connection, line2.end);

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:985',
        message: 'distances calculated',
        data: {
          distToLine1Start: distToLine1Start,
          distToLine1End: distToLine1End,
          distToLine2Start: distToLine2Start,
          distToLine2End: distToLine2End,
          line1EndCloser: distToLine1End < distToLine1Start,
          line2EndCloser: distToLine2End < distToLine2Start
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'post-fix',
        hypothesisId: 'D'
      })
    })["catch"](function () {});
    // #endregion

    // Вычисляем точки арки для каждой линии независимо от порядка параметров
    // Для каждой линии определяем направление от connection к дальнему концу линии
    // и вычисляем точку арки на этом направлении на расстоянии arcRadius

    // Вычисляем нормализованное направление каждой линии (от start к end)
    var line1Dir = lineDirection(line1);
    var line2Dir = lineDirection(line2);

    // Определяем, в какую сторону от connection находится точка арки для каждой линии
    // Если connection ближе к концу линии, точка арки должна быть в направлении от start к end (от connection к start)
    // Если connection ближе к началу, точка арки должна быть в направлении от end к start (от connection к end)
    var line1DirToFar = distToLine1End < distToLine1Start ? {
      x: -line1Dir.x,
      y: -line1Dir.y
    } : line1Dir;
    var line2DirToFar = distToLine2End < distToLine2Start ? {
      x: -line2Dir.x,
      y: -line2Dir.y
    } : line2Dir;

    // Вычисляем точки арки на линиях на расстоянии arcRadius от connection
    // Важно: эти точки вычисляются на основе конкретных линий, но пока без привязки к line1/line2
    var arcPoint1 = {
      x: connection.x + line1DirToFar.x * arcRadius,
      y: connection.y + line1DirToFar.y * arcRadius
    };
    var arcPoint2 = {
      x: connection.x + line2DirToFar.x * arcRadius,
      y: connection.y + line2DirToFar.y * arcRadius
    };

    // Теперь определяем, какая точка относится к какой линии (line1 или line2) по ID линий
    // Это гарантирует, что точки всегда привязаны к правильным линиям, независимо от порядка параметров
    // Для совместимости с существующим кодом, arcStartPoint всегда относится к line1, arcEndPoint - к line2
    var arcStartPoint = arcPoint1; // Всегда точка на line1 (первый параметр функции)
    var arcEndPoint = arcPoint2; // Всегда точка на line2 (второй параметр функции)

    // Используем эти направления для вычисления углов
    var dir1 = line1DirToFar;
    var dir2 = line2DirToFar;
    var angle1 = Math.atan2(dir1.y, dir1.x) * (180 / Math.PI);
    var angle2 = Math.atan2(dir2.y, dir2.x) * (180 / Math.PI);

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:993',
        message: 'directions calculated',
        data: {
          dir1: dir1,
          dir2: dir2,
          line1Dir: line1Dir,
          line2Dir: line2Dir,
          line1DirToFar: line1DirToFar,
          line2DirToFar: line2DirToFar,
          arcStartPoint: arcStartPoint,
          arcEndPoint: arcEndPoint
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'post-fix',
        hypothesisId: 'A'
      })
    })["catch"](function () {});
    // #endregion

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1004',
        message: 'arc points calculated',
        data: {
          arcStartPoint: arcStartPoint,
          arcEndPoint: arcEndPoint,
          arcRadius: arcRadius,
          angle1: angle1,
          angle2: angle2
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'post-fix',
        hypothesisId: 'B'
      })
    })["catch"](function () {});
    // #endregion

    // Вычисляем центр арки как пересечение перпендикуляров от точек арки к линиям
    // Точки арки находятся на линиях на расстоянии arcRadius от connection
    // Центр должен находиться на пересечении перпендикуляров от этих точек к линиям

    var angleDiff = Math.abs(angle2 - angle1);
    if (angleDiff > 180) {
      angleDiff = 360 - angleDiff;
    }
    var angleDiffRad = angleDiff * Math.PI / 180;

    // Перпендикуляры к линиям от точек арки
    // Перпендикуляр к dir1 (поворот на 90° против часовой стрелки)
    var perp1Dir = {
      x: -dir1.y,
      y: dir1.x
    };
    // Перпендикуляр к dir2 (поворот на 90° против часовой стрелки)
    var perp2Dir = {
      x: -dir2.y,
      y: dir2.x
    };

    // Определяем направление перпендикуляров внутрь угла
    // Вычисляем направление биссектрисы для определения направления
    var bisectorDirUnnormalized = {
      x: dir1.x + dir2.x,
      y: dir1.y + dir2.y
    };
    var bisectorLength = Math.sqrt(bisectorDirUnnormalized.x * bisectorDirUnnormalized.x + bisectorDirUnnormalized.y * bisectorDirUnnormalized.y);
    var bisectorDir = bisectorLength > 0.0001 ? {
      x: bisectorDirUnnormalized.x / bisectorLength,
      y: bisectorDirUnnormalized.y / bisectorLength
    } : {
      x: -dir1.y,
      y: dir1.x
    };

    // Проверяем, направлены ли перпендикуляры внутрь угла
    var perp1Dot = perp1Dir.x * bisectorDir.x + perp1Dir.y * bisectorDir.y;
    var perp2Dot = perp2Dir.x * bisectorDir.x + perp2Dir.y * bisectorDir.y;

    // Перпендикуляры должны идти внутрь угла, поэтому если скалярное произведение положительное, перпендикуляр направлен внутрь - оставляем как есть
    // Если отрицательное - направлен наружу, инвертируем
    var finalPerp1Dir = perp1Dot > 0 ? perp1Dir : {
      x: -perp1Dir.x,
      y: -perp1Dir.y
    };
    var finalPerp2Dir = perp2Dot > 0 ? perp2Dir : {
      x: -perp2Dir.x,
      y: -perp2Dir.y
    };

    // Пересечение прямых: arcStartPoint + t * finalPerp1Dir и arcEndPoint + s * finalPerp2Dir
    var dx = arcEndPoint.x - arcStartPoint.x;
    var dy = arcEndPoint.y - arcStartPoint.y;
    var denom = finalPerp1Dir.x * finalPerp2Dir.y - finalPerp1Dir.y * finalPerp2Dir.x;
    var arcCenter;
    if (Math.abs(denom) < 0.0001) {
      // Линии параллельны, используем fallback через биссектрису
      var _centerDist = angleDiffRad > 0.0001 ? arcRadius / Math.sin(angleDiffRad / 2) : arcRadius;
      arcCenter = {
        x: connection.x + bisectorDir.x * _centerDist,
        y: connection.y + bisectorDir.y * _centerDist
      };
    } else {
      var t = (dx * finalPerp2Dir.y - dy * finalPerp2Dir.x) / denom;
      arcCenter = {
        x: arcStartPoint.x + t * finalPerp1Dir.x,
        y: arcStartPoint.y + t * finalPerp1Dir.y
      };
    }

    // #region agent log
    var centerDist = angleDiffRad > 0.0001 ? arcRadius / Math.sin(angleDiffRad / 2) : arcRadius;
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1560',
        message: 'arc center calculation',
        data: {
          angle1: angle1,
          angle2: angle2,
          angleDiff: angleDiff,
          angleDiffRad: angleDiffRad,
          arcCenter: arcCenter,
          arcRadius: arcRadius,
          connection: connection,
          dir1: dir1,
          dir2: dir2,
          bisectorDir: bisectorDir,
          centerDist: centerDist,
          arcStartPoint: arcStartPoint,
          arcEndPoint: arcEndPoint,
          distFromCenterToStart: distance(arcCenter, arcStartPoint),
          distFromCenterToEnd: distance(arcCenter, arcEndPoint)
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'initial',
        hypothesisId: 'A'
      })
    })["catch"](function () {});
    // #endregion

    // Точки арки уже правильно вычислены от connection на линиях
    // Они находятся на расстоянии arcRadius от connection на каждой линии
    // Используем эти точки для обрезки линий - они гарантированно лежат на линиях

    // Вычисляем углы от центра к точкам арки для определения углов дуги
    var arcStartAngleRad = Math.atan2(arcStartPoint.y - arcCenter.y, arcStartPoint.x - arcCenter.x);
    var arcEndAngleRad = Math.atan2(arcEndPoint.y - arcCenter.y, arcEndPoint.x - arcCenter.x);

    // Вычисляем угол дуги как разность углов от начальной точки к конечной
    // Для fillet дуга всегда идет внутрь угла по кратчайшему пути
    var arcAngleRad = arcEndAngleRad - arcStartAngleRad;

    // Нормализуем угол к диапазону [-π, π]
    if (arcAngleRad > Math.PI) {
      arcAngleRad -= 2 * Math.PI;
    } else if (arcAngleRad < -Math.PI) {
      arcAngleRad += 2 * Math.PI;
    }
    var arcStartAngle = arcStartAngleRad * (180 / Math.PI);
    if (arcStartAngle > 180) arcStartAngle -= 360;
    if (arcStartAngle < -180) arcStartAngle += 360;

    // Угол дуги всегда должен быть положительным
    var arcAngle = Math.abs(arcAngleRad) * (180 / Math.PI);

    // Используем исходные точки арки для обрезки линий (они лежат на линиях)
    // После нормализации порядка линий, arcStartPoint всегда на line1, arcEndPoint всегда на line2
    // Это гарантирует, что результат не зависит от порядка параметров
    var finalArcStartPoint = arcStartPoint; // Всегда точка на line1 (линия с меньшим ID)
    var finalArcEndPoint = arcEndPoint; // Всегда точка на line2 (линия с большим ID)

    // Сохраняем исходные длины линий
    var originalLine1Length = line1.length || distance(line1.start, line1.end);
    var originalLine2Length = line2.length || distance(line2.start, line2.end);

    // После нормализации порядка линий, точки арки уже привязаны к правильным линиям
    var arcPointForLine1 = finalArcStartPoint; // Точка арки для line1
    var arcPointForLine2 = finalArcEndPoint; // Точка арки для line2

    var EPSILON = 0.01;

    // Определяем, какой конец каждой линии обрезается
    // Для line1: проверяем, к какому концу ближе точка арки, которая относится к line1
    var distArcPoint1ToLine1End = distance(arcPointForLine1, line1.end);
    var distArcPoint1ToLine1Start = distance(arcPointForLine1, line1.start);
    var line1EndTruncated = distArcPoint1ToLine1End + EPSILON < distArcPoint1ToLine1Start;

    // Для line2: проверяем, к какому концу ближе точка арки, которая относится к line2
    var distArcPoint2ToLine2End = distance(arcPointForLine2, line2.end);
    var distArcPoint2ToLine2Start = distance(arcPointForLine2, line2.start);
    var line2EndTruncated = distArcPoint2ToLine2End + EPSILON < distArcPoint2ToLine2Start;

    // Обрезаем линии до точек арки (используем правильные точки для каждой линии)
    var line1Update = line1EndTruncated ? {
      end: arcPointForLine1,
      length: originalLine1Length
    } : {
      start: arcPointForLine1,
      length: originalLine1Length
    };
    var line2Update = line2EndTruncated ? {
      end: arcPointForLine2,
      length: originalLine2Length
    } : {
      start: arcPointForLine2,
      length: originalLine2Length
    };

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1234',
        message: 'before updateElement',
        data: {
          line1Id: line1.id,
          line1: {
            start: line1.start,
            end: line1.end
          },
          line1Update: line1Update,
          line2Id: line2.id,
          line2: {
            start: line2.start,
            end: line2.end
          },
          line2Update: line2Update,
          arcStartPoint: finalArcStartPoint,
          arcEndPoint: finalArcEndPoint,
          originalArcStartPoint: arcStartPoint,
          originalArcEndPoint: arcEndPoint,
          line1EndTruncated: line1EndTruncated,
          line2EndTruncated: line2EndTruncated,
          distArcPoint1ToLine1End: distArcPoint1ToLine1End,
          distArcPoint1ToLine1Start: distArcPoint1ToLine1Start,
          distArcPoint2ToLine2End: distArcPoint2ToLine2End,
          distArcPoint2ToLine2Start: distArcPoint2ToLine2Start,
          distToLine1Start: distToLine1Start,
          distToLine1End: distToLine1End,
          distToLine2Start: distToLine2Start,
          distToLine2End: distToLine2End,
          connection: connection,
          dir1: dir1,
          dir2: dir2,
          arcCenter: arcCenter
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'post-fix',
        hypothesisId: 'A'
      })
    })["catch"](function () {});
    // #endregion

    // Обновляем обе линии
    updateElement(line1.id, line1Update);
    updateElement(line2.id, line2Update);

    // #region agent log
    var stateAfterUpdate = useEditorStore.getState();
    var line1After = stateAfterUpdate.elements.find(function (el) {
      return el.id === line1.id;
    });
    var line2After = stateAfterUpdate.elements.find(function (el) {
      return el.id === line2.id;
    });
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1254',
        message: 'after updateElement',
        data: {
          line1After: {
            start: line1After === null || line1After === void 0 ? void 0 : line1After.start,
            end: line1After === null || line1After === void 0 ? void 0 : line1After.end
          },
          line2After: {
            start: line2After === null || line2After === void 0 ? void 0 : line2After.start,
            end: line2After === null || line2After === void 0 ? void 0 : line2After.end
          },
          arcStartPoint: finalArcStartPoint,
          arcEndPoint: finalArcEndPoint,
          expectedLine1End: line1EndTruncated ? finalArcStartPoint : line1.end,
          expectedLine2Start: line2EndTruncated ? line2.start : finalArcEndPoint
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'initial',
        hypothesisId: 'B'
      })
    })["catch"](function () {});
    // #endregion

    // Создаем объект fillet, который содержит дугу и ссылки на обрезанные линии
    var fillet = {
      type: 'fillet',
      radius: arcRadius,
      line1Id: line1.id,
      // ID первой линии
      line2Id: line2.id,
      // ID второй линии
      // Дуга между линиями
      arc: {
        center: arcCenter,
        radius: arcRadius,
        startAngle: arcStartAngle,
        angle: arcAngle
      },
      // Сохраняем точки начала и конца арки (они лежат на линиях на расстоянии arcRadius от connection)
      // Важно: arcStartPoint всегда относится к line1, arcEndPoint всегда относится к line2
      // Это нужно для совместимости с существующим кодом (drawFillet и т.д.)
      arcStartPoint: arcPointForLine1,
      // Точка арки, которая относится к line1
      arcEndPoint: arcPointForLine2,
      // Точка арки, которая относится к line2
      // Данные для пересчета при изменении радиуса
      connection: connection,
      line1Direction: dir1,
      line2Direction: dir2,
      angle1: angle1,
      angle2: angle2,
      // Сохраняем информацию о том, какой конец каждой линии обрезается
      line1EndTruncated: line1EndTruncated,
      line2EndTruncated: line2EndTruncated
    };

    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/49b89e88-4674-4191-9133-bf7fd16c00a5', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        location: 'CanvasEditor.jsx:1088',
        message: 'fillet created',
        data: {
          fillet: CanvasEditor_objectSpread(CanvasEditor_objectSpread({}, fillet), {}, {
            arc: CanvasEditor_objectSpread({}, fillet.arc)
          })
        },
        timestamp: Date.now(),
        sessionId: 'debug-session',
        runId: 'post-fix',
        hypothesisId: 'C'
      })
    })["catch"](function () {});
    // #endregion

    // Добавляем fillet
    addElement(fillet);
    selectElement(null);
  };
  var drawChamferDimensionCallout = function drawChamferDimensionCallout(scope, element, isSelected, midPoint, depth) {
    var pointNumberMap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var allElements = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
    if (element.type !== 'chamfer') return;
    var depthMM = Math.round(pixelsToMM(depth));
    var text = "".concat(depthMM, " \u043C\u043C");
    var strokeColor = isSelected ? '#0073aa' : '#999';
    var lineWidth = 0.5;

    // Линия от середины фаски
    var leaderLength = 15;
    var horizontalLength = 40;
    var angle = 45;
    var angleRad = angle * Math.PI / 180;
    var leaderEndX = midPoint.x + Math.cos(angleRad) * leaderLength;
    var leaderEndY = midPoint.y - Math.sin(angleRad) * leaderLength;
    var horizontalStartX = leaderEndX;
    var horizontalStartY = leaderEndY;
    var horizontalEndX = leaderEndX + horizontalLength;
    var horizontalEndY = leaderEndY;
    var textY = horizontalStartY - 3;
    var leaderLine = new paper.Path.Line({
      from: [midPoint.x, midPoint.y],
      to: [leaderEndX, leaderEndY],
      strokeColor: strokeColor,
      strokeWidth: lineWidth
    });
    var horizontalLine = new paper.Path.Line({
      from: [horizontalStartX, horizontalStartY],
      to: [horizontalEndX, horizontalEndY],
      strokeColor: strokeColor,
      strokeWidth: lineWidth
    });

    // Создаем текст временно для получения его ширины
    var tempText = new paper.PointText({
      point: [0, 0],
      content: text,
      fillColor: strokeColor,
      fontSize: 11
    });
    var textWidth = tempText.bounds.width;
    tempText.remove(); // Удаляем временный текст

    // Выравниваем текст по правому краю горизонтальной линии
    var finalTextX = horizontalEndX - textWidth;

    // Текст - выровнен по правому краю горизонтальной линии
    var textElement = new paper.PointText({
      point: [finalTextX, textY],
      content: text,
      fillColor: strokeColor,
      fontSize: 11
    });

    // Перемещаем текст на передний план, чтобы он был виден поверх линий
    textElement.bringToFront();
  };
  var createChamferAtCorner = function createChamferAtCorner(line1Param, line2Param) {
    // Получаем актуальные версии линий из store перед созданием chamfer
    var currentState = useEditorStore.getState();
    var actualLine1 = currentState.elements.find(function (el) {
      return el.id === line1Param.id;
    });
    var actualLine2 = currentState.elements.find(function (el) {
      return el.id === line2Param.id;
    });
    if (!actualLine1 || !actualLine2 || actualLine1.type !== 'line' || actualLine2.type !== 'line') {
      return;
    }

    // Нормализуем порядок линий: всегда используем линию с меньшим ID как line1
    var line1 = actualLine1.id < actualLine2.id ? actualLine1 : actualLine2;
    var line2 = actualLine1.id < actualLine2.id ? actualLine2 : actualLine1;
    var connection = findConnectionPoint(line1, line2, 10);
    if (!connection) {
      return;
    }
    var chamferDepth = mmToPixels(2); // 2 мм по умолчанию

    // Определяем, какой конец каждой линии является точкой соединения
    var distToLine1Start = distance(connection, line1.start);
    var distToLine1End = distance(connection, line1.end);
    var distToLine2Start = distance(connection, line2.start);
    var distToLine2End = distance(connection, line2.end);

    // Вычисляем нормализованное направление каждой линии (от start к end)
    var line1Dir = lineDirection(line1);
    var line2Dir = lineDirection(line2);

    // Определяем, в какую сторону от connection находится точка обрезки для каждой линии
    var line1DirToFar = distToLine1End < distToLine1Start ? {
      x: -line1Dir.x,
      y: -line1Dir.y
    } : line1Dir;
    var line2DirToFar = distToLine2End < distToLine2Start ? {
      x: -line2Dir.x,
      y: -line2Dir.y
    } : line2Dir;

    // Вычисляем точки обрезки на линиях на расстоянии chamferDepth от connection
    var chamferStartPoint = {
      x: connection.x + line1DirToFar.x * chamferDepth,
      y: connection.y + line1DirToFar.y * chamferDepth
    };
    var chamferEndPoint = {
      x: connection.x + line2DirToFar.x * chamferDepth,
      y: connection.y + line2DirToFar.y * chamferDepth
    };

    // Используем эти направления для вычисления углов
    var dir1 = line1DirToFar;
    var dir2 = line2DirToFar;
    var angle1 = Math.atan2(dir1.y, dir1.x) * (180 / Math.PI);
    var angle2 = Math.atan2(dir2.y, dir2.x) * (180 / Math.PI);

    // Сохраняем исходные длины линий
    var originalLine1Length = line1.length || distance(line1.start, line1.end);
    var originalLine2Length = line2.length || distance(line2.start, line2.end);
    var EPSILON = 0.01;

    // Определяем, какой конец каждой линии обрезается
    var distChamferStartToLine1End = distance(chamferStartPoint, line1.end);
    var distChamferStartToLine1Start = distance(chamferStartPoint, line1.start);
    var line1EndTruncated = distChamferStartToLine1End + EPSILON < distChamferStartToLine1Start;
    var distChamferEndToLine2End = distance(chamferEndPoint, line2.end);
    var distChamferEndToLine2Start = distance(chamferEndPoint, line2.start);
    var line2EndTruncated = distChamferEndToLine2End + EPSILON < distChamferEndToLine2Start;

    // Обрезаем линии до точек обрезки
    var line1Update = line1EndTruncated ? {
      end: chamferStartPoint,
      length: originalLine1Length
    } : {
      start: chamferStartPoint,
      length: originalLine1Length
    };
    var line2Update = line2EndTruncated ? {
      end: chamferEndPoint,
      length: originalLine2Length
    } : {
      start: chamferEndPoint,
      length: originalLine2Length
    };

    // Обновляем обе линии
    updateElement(line1.id, line1Update);
    updateElement(line2.id, line2Update);

    // Создаем объект chamfer, который содержит прямую линию и ссылки на обрезанные линии
    var chamfer = {
      type: 'chamfer',
      depth: chamferDepth,
      line1Id: line1.id,
      line2Id: line2.id,
      start: chamferStartPoint,
      end: chamferEndPoint,
      connection: connection,
      line1Direction: dir1,
      line2Direction: dir2,
      angle1: angle1,
      angle2: angle2,
      line1EndTruncated: line1EndTruncated,
      line2EndTruncated: line2EndTruncated
    };

    // Добавляем chamfer
    addElement(chamfer);
    selectElement(null);
  };
  return /*#__PURE__*/external_React_default().createElement("div", {
    ref: containerRef,
    className: "canvas-editor"
  }, /*#__PURE__*/external_React_default().createElement("canvas", {
    ref: canvasRef,
    id: "plintus-paperjs-canvas",
    style: {
      width: '100%',
      height: '100%',
      display: 'block'
    }
  }));
}
/* harmony default export */ const components_Canvas_CanvasEditor = (CanvasEditor_CanvasEditor);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./admin/js/src/components/Toolbar/Toolbar.css
var Toolbar = __webpack_require__(925);
;// ./admin/js/src/components/Toolbar/Toolbar.css

      
      
      
      
      
      
      
      
      

var Toolbar_options = {};

Toolbar_options.styleTagTransform = (styleTagTransform_default());
Toolbar_options.setAttributes = (setAttributesWithoutAttributes_default());

      Toolbar_options.insert = insertBySelector_default().bind(null, "head");
    
Toolbar_options.domAPI = (styleDomAPI_default());
Toolbar_options.insertStyleElement = (insertStyleElement_default());

var Toolbar_update = injectStylesIntoStyleTag_default()(Toolbar/* default */.A, Toolbar_options);




       /* harmony default export */ const Toolbar_Toolbar = (Toolbar/* default */.A && Toolbar/* default */.A.locals ? Toolbar/* default */.A.locals : undefined);

;// ./admin/js/src/components/Toolbar/ToolButton.jsx


var FilletIcon = function FilletIcon() {
  return /*#__PURE__*/external_React_default().createElement("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/external_React_default().createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M19.9993 16.1803V9C19.9993 6.32472 17.8982 4.14053 15.2561 4.00684L14.9993 4L7.81931 4.00029C7.6522 3.52063 7.36603 3.09125 6.98763 2.7524C6.60923 2.41355 6.15099 2.17633 5.65586 2.06297C5.16074 1.94961 4.64493 1.96382 4.15679 2.10427C3.66866 2.24472 3.22418 2.50682 2.86501 2.86598C2.50584 3.22515 2.24375 3.66963 2.1033 4.15777C1.96284 4.64591 1.94863 5.16171 2.062 5.65684C2.17536 6.15197 2.41258 6.61021 2.75143 6.98861C3.09027 7.36701 3.382 7.54729 3.99931 7.82029C4.61663 8.09329 5.5 8 5.99931 7.82029C6.49862 7.64058 6.79962 7.43018 7.11441 7.11539C7.42921 6.80059 7.66999 6.41969 7.81931 6.00029L14.9993 6C16.6562 6 17.9993 7.34315 17.9993 9V16.1803C17.5799 16.3296 17.199 16.5704 16.8842 16.8852C16.5694 17.2 16.3286 17.5809 16.1793 18.0003C16.0014 18.5 16.0122 19.5206 16.1793 20.0003C16.3464 20.48 16.6326 20.9093 17.011 21.2482C17.3894 21.587 17.8476 21.8242 18.3428 21.9376C18.8379 22.051 19.3537 22.0368 19.8418 21.8963C20.33 21.7559 20.7744 21.4938 21.1336 21.1346C21.4928 20.7754 21.7549 20.3309 21.8953 19.8428C22.0358 19.3547 22.05 18.8389 21.9366 18.3437C21.8233 17.8486 21.586 17.3904 21.2472 17.012C20.9084 16.6336 20.479 16.3474 19.9993 16.1803ZM5.55488 4.16882C5.39043 4.05894 5.19709 4.00029 4.99931 4.00029C4.7341 4.00029 4.47974 4.10565 4.29221 4.29318C4.10467 4.48072 3.99931 4.73507 3.99931 5.00029C3.99931 5.19807 4.05796 5.39141 4.16784 5.55586C4.27772 5.72031 4.4339 5.84848 4.61663 5.92417C4.79936 5.99986 5.00042 6.01966 5.1944 5.98107C5.38838 5.94249 5.56657 5.84725 5.70642 5.7074C5.84627 5.56754 5.94151 5.38936 5.9801 5.19538C6.01868 5.0014 5.99888 4.80033 5.92319 4.61761C5.8475 4.43488 5.71933 4.2787 5.55488 4.16882ZM18.4437 19.8318C18.6082 19.9416 18.8015 20.0003 18.9993 20.0003C19.2645 20.0003 19.5189 19.8949 19.7064 19.7074C19.894 19.5199 19.9993 19.2655 19.9993 19.0003C19.9993 18.8025 19.9407 18.6092 19.8308 18.4447C19.7209 18.2803 19.5647 18.1521 19.382 18.0764C19.1993 18.0007 18.9982 17.9809 18.8042 18.0195C18.6102 18.0581 18.4321 18.1533 18.2922 18.2932C18.1524 18.433 18.0571 18.6112 18.0185 18.8052C17.9799 18.9992 17.9997 19.2002 18.0754 19.383C18.1511 19.5657 18.2793 19.7219 18.4437 19.8318Z",
    fill: "currentColor"
  }));
};
var ChamferIcon = function ChamferIcon() {
  return /*#__PURE__*/external_React_default().createElement("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/external_React_default().createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M19.9993 16.1803V12L12.5 4L7.81931 4.00029C7.6522 3.52063 7.36603 3.09125 6.98763 2.7524C6.60923 2.41355 6.15099 2.17633 5.65586 2.06297C5.16074 1.94961 4.64493 1.96382 4.15679 2.10427C3.66866 2.24472 3.22418 2.50682 2.86501 2.86598C2.50584 3.22515 2.24375 3.66963 2.1033 4.15777C1.96284 4.64591 1.94863 5.16171 2.062 5.65684C2.17536 6.15197 2.41258 6.61021 2.75143 6.98861C3.09027 7.36701 3.382 7.54729 3.99931 7.82029C4.61663 8.09329 5.5 8 5.99931 7.82029C6.49862 7.64058 6.79962 7.43018 7.11441 7.11539C7.42921 6.80059 7.66999 6.41969 7.81931 6.00029L11.5 5.98107L17.9993 13V16.1803C17.5799 16.3296 17.199 16.5704 16.8842 16.8852C16.5694 17.2 16.3286 17.5809 16.1793 18.0003C16.0014 18.5 16.0122 19.5206 16.1793 20.0003C16.3464 20.48 16.6326 20.9093 17.011 21.2482C17.3894 21.587 17.8476 21.8242 18.3428 21.9376C18.8379 22.051 19.3537 22.0368 19.8418 21.8963C20.33 21.7559 20.7744 21.4938 21.1336 21.1346C21.4928 20.7754 21.7549 20.3309 21.8953 19.8428C22.0358 19.3547 22.05 18.8389 21.9366 18.3437C21.8233 17.8486 21.586 17.3904 21.2472 17.012C20.9084 16.6336 20.479 16.3474 19.9993 16.1803ZM5.55488 4.16882C5.39043 4.05894 5.19709 4.00029 4.99931 4.00029C4.7341 4.00029 4.47974 4.10565 4.29221 4.29318C4.10467 4.48072 3.99931 4.73507 3.99931 5.00029C3.99931 5.19807 4.05796 5.39141 4.16784 5.55586C4.27772 5.72031 4.4339 5.84848 4.61663 5.92417C4.79936 5.99986 5.00042 6.01966 5.1944 5.98107C5.38838 5.94249 5.56657 5.84725 5.70642 5.7074C5.84627 5.56754 5.94151 5.38936 5.9801 5.19538C6.01868 5.0014 5.99888 4.80033 5.92319 4.61761C5.8475 4.43488 5.71933 4.2787 5.55488 4.16882ZM18.4437 19.8318C18.6082 19.9416 18.8015 20.0003 18.9993 20.0003C19.2645 20.0003 19.5189 19.8949 19.7064 19.7074C19.894 19.5199 19.9993 19.2655 19.9993 19.0003C19.9993 18.8025 19.9407 18.6092 19.8308 18.4447C19.7209 18.2803 19.5647 18.1521 19.382 18.0764C19.1993 18.0007 18.9982 17.9809 18.8042 18.0195C18.6102 18.0581 18.4321 18.1533 18.2922 18.2932C18.1524 18.433 18.0571 18.6112 18.0185 18.8052C17.9799 18.9992 17.9997 19.2002 18.0754 19.383C18.1511 19.5657 18.2793 19.7219 18.4437 19.8318Z",
    fill: "currentColor"
  }));
};
function ToolButton(_ref) {
  var tool = _ref.tool,
    isActive = _ref.isActive,
    onClick = _ref.onClick;
  return /*#__PURE__*/external_React_default().createElement("button", {
    type: "button",
    className: "plintus-tool-button ".concat(isActive ? 'active' : ''),
    onClick: onClick,
    title: tool.label
  }, tool.id === 'arc' ? /*#__PURE__*/external_React_default().createElement(FilletIcon, null) : tool.id === 'chamfer' ? /*#__PURE__*/external_React_default().createElement(ChamferIcon, null) : /*#__PURE__*/external_React_default().createElement("i", {
    className: "fs-28 uil ".concat(tool.icon)
  }));
}
/* harmony default export */ const Toolbar_ToolButton = (ToolButton);
;// ./admin/js/src/components/Toolbar/Toolbar.jsx




function Toolbar_Toolbar_Toolbar() {
  var _useEditorStore = useEditorStore(),
    selectedTool = _useEditorStore.selectedTool,
    setSelectedTool = _useEditorStore.setSelectedTool,
    dimensionsVisible = _useEditorStore.dimensionsVisible,
    toggleDimensionsVisible = _useEditorStore.toggleDimensionsVisible,
    zoomIn = _useEditorStore.zoomIn,
    zoomOut = _useEditorStore.zoomOut,
    resetZoom = _useEditorStore.resetZoom;
  var tools = [{
    id: 'line',
    label: 'Рисование',
    icon: 'uil-edit-alt'
  }, {
    id: 'select',
    label: 'Редактировать',
    icon: 'uil-vector-square'
  }, {
    id: 'arc',
    label: 'Скругление',
    icon: 'uil-circle'
  }, {
    id: 'chamfer',
    label: 'Фаска',
    icon: 'uil-angle-double-down'
  }, {
    id: 'delete',
    label: 'Удаление',
    icon: 'uil-trash-alt'
  }];
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-toolbar"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-toolbar-section"
  }, tools.map(function (tool) {
    return /*#__PURE__*/external_React_default().createElement(Toolbar_ToolButton, {
      key: tool.id,
      tool: tool,
      isActive: selectedTool === tool.id,
      onClick: function onClick() {
        return setSelectedTool(tool.id);
      }
    });
  })), /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-toolbar-section plintus-toolbar-section-right"
  }, /*#__PURE__*/external_React_default().createElement("button", {
    type: "button",
    onClick: function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      resetZoom();
    },
    title: "\u0421\u0431\u0440\u043E\u0441 \u043C\u0430\u0441\u0448\u0442\u0430\u0431\u0430"
  }, /*#__PURE__*/external_React_default().createElement("i", {
    className: "fs-28 uil uil-expand-arrows-alt"
  })), /*#__PURE__*/external_React_default().createElement("button", {
    type: "button",
    onClick: function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      zoomOut();
    },
    title: "\u0423\u043C\u0435\u043D\u044C\u0448\u0438\u0442\u044C"
  }, /*#__PURE__*/external_React_default().createElement("i", {
    className: "fs-28 uil uil-minus-circle"
  })), /*#__PURE__*/external_React_default().createElement("button", {
    type: "button",
    onClick: function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      zoomIn();
    },
    title: "\u041F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u044C"
  }, /*#__PURE__*/external_React_default().createElement("i", {
    className: "fs-28 uil uil-plus-circle"
  })), /*#__PURE__*/external_React_default().createElement("button", {
    type: "button",
    onClick: function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      toggleDimensionsVisible();
    },
    className: dimensionsVisible ? 'active' : '',
    title: "Show/Hide Dimensions"
  }, /*#__PURE__*/external_React_default().createElement("i", {
    className: "fs-28 uil uil-ruler"
  }))));
}
/* harmony default export */ const components_Toolbar_Toolbar = (Toolbar_Toolbar_Toolbar);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./admin/js/src/components/Toolbar/VerticalToolbar.css
var VerticalToolbar = __webpack_require__(47);
;// ./admin/js/src/components/Toolbar/VerticalToolbar.css

      
      
      
      
      
      
      
      
      

var VerticalToolbar_options = {};

VerticalToolbar_options.styleTagTransform = (styleTagTransform_default());
VerticalToolbar_options.setAttributes = (setAttributesWithoutAttributes_default());

      VerticalToolbar_options.insert = insertBySelector_default().bind(null, "head");
    
VerticalToolbar_options.domAPI = (styleDomAPI_default());
VerticalToolbar_options.insertStyleElement = (insertStyleElement_default());

var VerticalToolbar_update = injectStylesIntoStyleTag_default()(VerticalToolbar/* default */.A, VerticalToolbar_options);




       /* harmony default export */ const Toolbar_VerticalToolbar = (VerticalToolbar/* default */.A && VerticalToolbar/* default */.A.locals ? VerticalToolbar/* default */.A.locals : undefined);

;// ./admin/js/src/components/Toolbar/VerticalToolbar.jsx



var VerticalToolbar_FilletIcon = function FilletIcon() {
  return /*#__PURE__*/external_React_default().createElement("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/external_React_default().createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M19.9993 16.1803V9C19.9993 6.32472 17.8982 4.14053 15.2561 4.00684L14.9993 4L7.81931 4.00029C7.6522 3.52063 7.36603 3.09125 6.98763 2.7524C6.60923 2.41355 6.15099 2.17633 5.65586 2.06297C5.16074 1.94961 4.64493 1.96382 4.15679 2.10427C3.66866 2.24472 3.22418 2.50682 2.86501 2.86598C2.50584 3.22515 2.24375 3.66963 2.1033 4.15777C1.96284 4.64591 1.94863 5.16171 2.062 5.65684C2.17536 6.15197 2.41258 6.61021 2.75143 6.98861C3.09027 7.36701 3.382 7.54729 3.99931 7.82029C4.61663 8.09329 5.5 8 5.99931 7.82029C6.49862 7.64058 6.79962 7.43018 7.11441 7.11539C7.42921 6.80059 7.66999 6.41969 7.81931 6.00029L14.9993 6C16.6562 6 17.9993 7.34315 17.9993 9V16.1803C17.5799 16.3296 17.199 16.5704 16.8842 16.8852C16.5694 17.2 16.3286 17.5809 16.1793 18.0003C16.0014 18.5 16.0122 19.5206 16.1793 20.0003C16.3464 20.48 16.6326 20.9093 17.011 21.2482C17.3894 21.587 17.8476 21.8242 18.3428 21.9376C18.8379 22.051 19.3537 22.0368 19.8418 21.8963C20.33 21.7559 20.7744 21.4938 21.1336 21.1346C21.4928 20.7754 21.7549 20.3309 21.8953 19.8428C22.0358 19.3547 22.05 18.8389 21.9366 18.3437C21.8233 17.8486 21.586 17.3904 21.2472 17.012C20.9084 16.6336 20.479 16.3474 19.9993 16.1803ZM5.55488 4.16882C5.39043 4.05894 5.19709 4.00029 4.99931 4.00029C4.7341 4.00029 4.47974 4.10565 4.29221 4.29318C4.10467 4.48072 3.99931 4.73507 3.99931 5.00029C3.99931 5.19807 4.05796 5.39141 4.16784 5.55586C4.27772 5.72031 4.4339 5.84848 4.61663 5.92417C4.79936 5.99986 5.00042 6.01966 5.1944 5.98107C5.38838 5.94249 5.56657 5.84725 5.70642 5.7074C5.84627 5.56754 5.94151 5.38936 5.9801 5.19538C6.01868 5.0014 5.99888 4.80033 5.92319 4.61761C5.8475 4.43488 5.71933 4.2787 5.55488 4.16882ZM18.4437 19.8318C18.6082 19.9416 18.8015 20.0003 18.9993 20.0003C19.2645 20.0003 19.5189 19.8949 19.7064 19.7074C19.894 19.5199 19.9993 19.2655 19.9993 19.0003C19.9993 18.8025 19.9407 18.6092 19.8308 18.4447C19.7209 18.2803 19.5647 18.1521 19.382 18.0764C19.1993 18.0007 18.9982 17.9809 18.8042 18.0195C18.6102 18.0581 18.4321 18.1533 18.2922 18.2932C18.1524 18.433 18.0571 18.6112 18.0185 18.8052C17.9799 18.9992 17.9997 19.2002 18.0754 19.383C18.1511 19.5657 18.2793 19.7219 18.4437 19.8318Z",
    fill: "currentColor"
  }));
};
var VerticalToolbar_ChamferIcon = function ChamferIcon() {
  return /*#__PURE__*/external_React_default().createElement("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/external_React_default().createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M19.9993 16.1803V12L12.5 4L7.81931 4.00029C7.6522 3.52063 7.36603 3.09125 6.98763 2.7524C6.60923 2.41355 6.15099 2.17633 5.65586 2.06297C5.16074 1.94961 4.64493 1.96382 4.15679 2.10427C3.66866 2.24472 3.22418 2.50682 2.86501 2.86598C2.50584 3.22515 2.24375 3.66963 2.1033 4.15777C1.96284 4.64591 1.94863 5.16171 2.062 5.65684C2.17536 6.15197 2.41258 6.61021 2.75143 6.98861C3.09027 7.36701 3.382 7.54729 3.99931 7.82029C4.61663 8.09329 5.5 8 5.99931 7.82029C6.49862 7.64058 6.79962 7.43018 7.11441 7.11539C7.42921 6.80059 7.66999 6.41969 7.81931 6.00029L11.5 5.98107L17.9993 13V16.1803C17.5799 16.3296 17.199 16.5704 16.8842 16.8852C16.5694 17.2 16.3286 17.5809 16.1793 18.0003C16.0014 18.5 16.0122 19.5206 16.1793 20.0003C16.3464 20.48 16.6326 20.9093 17.011 21.2482C17.3894 21.587 17.8476 21.8242 18.3428 21.9376C18.8379 22.051 19.3537 22.0368 19.8418 21.8963C20.33 21.7559 20.7744 21.4938 21.1336 21.1346C21.4928 20.7754 21.7549 20.3309 21.8953 19.8428C22.0358 19.3547 22.05 18.8389 21.9366 18.3437C21.8233 17.8486 21.586 17.3904 21.2472 17.012C20.9084 16.6336 20.479 16.3474 19.9993 16.1803ZM5.55488 4.16882C5.39043 4.05894 5.19709 4.00029 4.99931 4.00029C4.7341 4.00029 4.47974 4.10565 4.29221 4.29318C4.10467 4.48072 3.99931 4.73507 3.99931 5.00029C3.99931 5.19807 4.05796 5.39141 4.16784 5.55586C4.27772 5.72031 4.4339 5.84848 4.61663 5.92417C4.79936 5.99986 5.00042 6.01966 5.1944 5.98107C5.38838 5.94249 5.56657 5.84725 5.70642 5.7074C5.84627 5.56754 5.94151 5.38936 5.9801 5.19538C6.01868 5.0014 5.99888 4.80033 5.92319 4.61761C5.8475 4.43488 5.71933 4.2787 5.55488 4.16882ZM18.4437 19.8318C18.6082 19.9416 18.8015 20.0003 18.9993 20.0003C19.2645 20.0003 19.5189 19.8949 19.7064 19.7074C19.894 19.5199 19.9993 19.2655 19.9993 19.0003C19.9993 18.8025 19.9407 18.6092 19.8308 18.4447C19.7209 18.2803 19.5647 18.1521 19.382 18.0764C19.1993 18.0007 18.9982 17.9809 18.8042 18.0195C18.6102 18.0581 18.4321 18.1533 18.2922 18.2932C18.1524 18.433 18.0571 18.6112 18.0185 18.8052C17.9799 18.9992 17.9997 19.2002 18.0754 19.383C18.1511 19.5657 18.2793 19.7219 18.4437 19.8318Z",
    fill: "currentColor"
  }));
};
function VerticalToolbar_VerticalToolbar() {
  var _useEditorStore = useEditorStore(),
    selectedTool = _useEditorStore.selectedTool,
    setSelectedTool = _useEditorStore.setSelectedTool;
  var tools = [{
    id: 'line',
    label: 'Рисование',
    icon: 'uil-edit-alt'
  }, {
    id: 'select',
    label: 'Редактировать',
    icon: 'uil-vector-square'
  }, {
    id: 'arc',
    label: 'Скругление',
    icon: 'uil-circle'
  }, {
    id: 'chamfer',
    label: 'Фаска',
    icon: 'uil-angle-double-down'
  }, {
    id: 'delete',
    label: 'Удаление',
    icon: 'uil-trash-alt'
  }];
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-vertical-toolbar"
  }, tools.map(function (tool) {
    return /*#__PURE__*/external_React_default().createElement("button", {
      key: tool.id,
      type: "button",
      className: "plintus-vertical-tool-button ".concat(selectedTool === tool.id ? 'active' : ''),
      onClick: function onClick() {
        return setSelectedTool(tool.id);
      },
      title: tool.label
    }, tool.id === 'arc' ? /*#__PURE__*/external_React_default().createElement("div", {
      className: "py-2"
    }, /*#__PURE__*/external_React_default().createElement(VerticalToolbar_FilletIcon, null)) : tool.id === 'chamfer' ? /*#__PURE__*/external_React_default().createElement("div", {
      className: "py-2"
    }, /*#__PURE__*/external_React_default().createElement(VerticalToolbar_ChamferIcon, null)) : /*#__PURE__*/external_React_default().createElement("i", {
      className: "fs-28 uil ".concat(tool.icon)
    }), /*#__PURE__*/external_React_default().createElement("span", {
      className: "plintus-vertical-tool-button-text"
    }, tool.label));
  }));
}
/* harmony default export */ const components_Toolbar_VerticalToolbar = (VerticalToolbar_VerticalToolbar);
;// ./admin/js/src/components/Sidebar/LineProperties.jsx



function LineProperties(_ref) {
  var elements = _ref.elements;
  // Вычисляем общую длину всех выбранных линий
  var totalLength = elements.reduce(function (sum, element) {
    if (element.start && element.end) {
      return sum + distance(element.start, element.end);
    } else if (element.length) {
      return sum + element.length;
    }
    return sum;
  }, 0);
  var totalLengthText = formatLengthMM(totalLength);
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "line-properties"
  }, /*#__PURE__*/external_React_default().createElement("h4", null, "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u043B\u0438\u043D\u0438\u0438"), elements.length > 1 && /*#__PURE__*/external_React_default().createElement("p", {
    className: "line-count"
  }, "\u041B\u0438\u043D\u0438\u0439: ", elements.length), /*#__PURE__*/external_React_default().createElement("div", {
    className: "property-item"
  }, /*#__PURE__*/external_React_default().createElement("label", null, "\u0414\u043B\u0438\u043D\u0430:"), /*#__PURE__*/external_React_default().createElement("span", {
    className: "property-value"
  }, totalLengthText)));
}
/* harmony default export */ const Sidebar_LineProperties = (LineProperties);
;// ./admin/js/src/components/Sidebar/ArcProperties.jsx
function ArcProperties_slicedToArray(r, e) { return ArcProperties_arrayWithHoles(r) || ArcProperties_iterableToArrayLimit(r, e) || ArcProperties_unsupportedIterableToArray(r, e) || ArcProperties_nonIterableRest(); }
function ArcProperties_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function ArcProperties_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return ArcProperties_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? ArcProperties_arrayLikeToArray(r, a) : void 0; } }
function ArcProperties_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ArcProperties_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function ArcProperties_arrayWithHoles(r) { if (Array.isArray(r)) return r; }



function ArcProperties(_ref) {
  var element = _ref.element;
  var _useEditorStore = useEditorStore(),
    updateElement = _useEditorStore.updateElement;
  var _useState = (0,external_React_.useState)(element.radius ? Math.round(pixelsToMM(element.radius)) : 5),
    _useState2 = ArcProperties_slicedToArray(_useState, 2),
    radiusMM = _useState2[0],
    setRadiusMM = _useState2[1];
  var _useState3 = (0,external_React_.useState)(element.angle ? Math.round(element.angle) : 90),
    _useState4 = ArcProperties_slicedToArray(_useState3, 2),
    angle = _useState4[0],
    setAngle = _useState4[1];

  // Синхронизируем значения с элементом при его изменении
  (0,external_React_.useEffect)(function () {
    if (element.radius) {
      var newRadiusMM = Math.round(pixelsToMM(element.radius));
      setRadiusMM(newRadiusMM);
    }
    if (element.angle !== undefined) {
      setAngle(Math.round(element.angle));
    }
  }, [element.radius, element.angle]);
  var handleRadiusChange = function handleRadiusChange(e) {
    var newValue = parseFloat(e.target.value);
    if (!isNaN(newValue) && newValue > 0) {
      setRadiusMM(newValue);
      updateElement(element.id, {
        radius: mmToPixels(newValue)
      });
    }
  };
  var handleAngleChange = function handleAngleChange(e) {
    var newValue = parseFloat(e.target.value);
    if (!isNaN(newValue) && newValue >= 0 && newValue <= 360) {
      setAngle(newValue);
      updateElement(element.id, {
        angle: newValue
      });
    }
  };

  // Вычисляем длину дуги
  var radius = element.radius || 0;
  var angleRad = angle * Math.PI / 180;
  var arcLength = radius * angleRad;
  var arcLengthText = formatLengthMM(arcLength);
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "arc-properties"
  }, /*#__PURE__*/external_React_default().createElement("h4", null, "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0434\u0443\u0433\u0438"), /*#__PURE__*/external_React_default().createElement("div", {
    className: "property-item"
  }, /*#__PURE__*/external_React_default().createElement("label", {
    htmlFor: "arc-radius"
  }, "\u0420\u0430\u0434\u0438\u0443\u0441 (\u043C\u043C):"), /*#__PURE__*/external_React_default().createElement("input", {
    id: "arc-radius",
    type: "number",
    min: "1",
    step: "1",
    value: radiusMM,
    onChange: handleRadiusChange,
    className: "property-input"
  })), /*#__PURE__*/external_React_default().createElement("div", {
    className: "property-item"
  }, /*#__PURE__*/external_React_default().createElement("label", {
    htmlFor: "arc-angle"
  }, "\u0423\u0433\u043E\u043B (\xB0):"), /*#__PURE__*/external_React_default().createElement("input", {
    id: "arc-angle",
    type: "number",
    min: "0",
    max: "360",
    step: "1",
    value: angle,
    onChange: handleAngleChange,
    className: "property-input"
  })), /*#__PURE__*/external_React_default().createElement("div", {
    className: "property-item"
  }, /*#__PURE__*/external_React_default().createElement("label", null, "\u0414\u043B\u0438\u043D\u0430:"), /*#__PURE__*/external_React_default().createElement("span", {
    className: "property-value"
  }, arcLengthText)));
}
/* harmony default export */ const Sidebar_ArcProperties = (ArcProperties);
;// ./admin/js/src/components/Sidebar/FilletProperties.jsx
function FilletProperties_slicedToArray(r, e) { return FilletProperties_arrayWithHoles(r) || FilletProperties_iterableToArrayLimit(r, e) || FilletProperties_unsupportedIterableToArray(r, e) || FilletProperties_nonIterableRest(); }
function FilletProperties_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function FilletProperties_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return FilletProperties_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? FilletProperties_arrayLikeToArray(r, a) : void 0; } }
function FilletProperties_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function FilletProperties_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function FilletProperties_arrayWithHoles(r) { if (Array.isArray(r)) return r; }



function FilletProperties(_ref) {
  var element = _ref.element;
  var _useEditorStore = useEditorStore(),
    updateFilletRadius = _useEditorStore.updateFilletRadius;
  var _useState = (0,external_React_.useState)(element.radius ? Math.round(pixelsToMM(element.radius)) : 3),
    _useState2 = FilletProperties_slicedToArray(_useState, 2),
    radiusMM = _useState2[0],
    setRadiusMM = _useState2[1];

  // Синхронизируем значение с элементом при его изменении
  (0,external_React_.useEffect)(function () {
    if (element.radius) {
      var newRadiusMM = Math.round(pixelsToMM(element.radius));
      setRadiusMM(newRadiusMM);
    }
  }, [element.radius]);
  var handleRadiusChange = function handleRadiusChange(e) {
    var newValue = parseFloat(e.target.value);
    if (!isNaN(newValue) && newValue > 0) {
      setRadiusMM(newValue);
      updateFilletRadius(element.id, newValue);
    }
  };
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "fillet-properties"
  }, "d            ", /*#__PURE__*/external_React_default().createElement("h4", null, "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0441\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u044F"), /*#__PURE__*/external_React_default().createElement("div", {
    className: "property-item"
  }, /*#__PURE__*/external_React_default().createElement("label", {
    htmlFor: "fillet-radius"
  }, "\u0421\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u0435 (\u043C\u043C):"), /*#__PURE__*/external_React_default().createElement("input", {
    id: "fillet-radius",
    type: "number",
    min: "1",
    step: "1",
    value: radiusMM,
    onChange: handleRadiusChange,
    className: "property-input"
  })));
}
/* harmony default export */ const Sidebar_FilletProperties = (FilletProperties);
;// ./admin/js/src/components/Sidebar/ChamferProperties.jsx
function ChamferProperties_slicedToArray(r, e) { return ChamferProperties_arrayWithHoles(r) || ChamferProperties_iterableToArrayLimit(r, e) || ChamferProperties_unsupportedIterableToArray(r, e) || ChamferProperties_nonIterableRest(); }
function ChamferProperties_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function ChamferProperties_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return ChamferProperties_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? ChamferProperties_arrayLikeToArray(r, a) : void 0; } }
function ChamferProperties_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ChamferProperties_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function ChamferProperties_arrayWithHoles(r) { if (Array.isArray(r)) return r; }



function ChamferProperties(_ref) {
  var element = _ref.element;
  var _useEditorStore = useEditorStore(),
    updateChamferDepth = _useEditorStore.updateChamferDepth;
  var _useState = (0,external_React_.useState)(element.depth ? Math.round(pixelsToMM(element.depth)) : 2),
    _useState2 = ChamferProperties_slicedToArray(_useState, 2),
    depthMM = _useState2[0],
    setDepthMM = _useState2[1];

  // Синхронизируем значение с элементом при его изменении
  (0,external_React_.useEffect)(function () {
    if (element.depth) {
      var newDepthMM = Math.round(pixelsToMM(element.depth));
      setDepthMM(newDepthMM);
    }
  }, [element.depth]);
  var handleDepthChange = function handleDepthChange(e) {
    var newValue = parseFloat(e.target.value);
    if (!isNaN(newValue) && newValue > 0) {
      setDepthMM(newValue);
      updateChamferDepth(element.id, newValue);
    }
  };
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "chamfer-properties"
  }, /*#__PURE__*/external_React_default().createElement("h4", null, "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0444\u0430\u0441\u043A\u0438"), /*#__PURE__*/external_React_default().createElement("div", {
    className: "property-item"
  }, /*#__PURE__*/external_React_default().createElement("label", {
    htmlFor: "chamfer-depth"
  }, "\u0413\u043B\u0443\u0431\u0438\u043D\u0430 (\u043C\u043C):"), /*#__PURE__*/external_React_default().createElement("input", {
    id: "chamfer-depth",
    type: "number",
    min: "1",
    step: "1",
    value: depthMM,
    onChange: handleDepthChange,
    className: "property-input"
  })));
}
/* harmony default export */ const Sidebar_ChamferProperties = (ChamferProperties);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./admin/js/src/components/Sidebar/PropertiesPanel.css
var PropertiesPanel = __webpack_require__(38);
;// ./admin/js/src/components/Sidebar/PropertiesPanel.css

      
      
      
      
      
      
      
      
      

var PropertiesPanel_options = {};

PropertiesPanel_options.styleTagTransform = (styleTagTransform_default());
PropertiesPanel_options.setAttributes = (setAttributesWithoutAttributes_default());

      PropertiesPanel_options.insert = insertBySelector_default().bind(null, "head");
    
PropertiesPanel_options.domAPI = (styleDomAPI_default());
PropertiesPanel_options.insertStyleElement = (insertStyleElement_default());

var PropertiesPanel_update = injectStylesIntoStyleTag_default()(PropertiesPanel/* default */.A, PropertiesPanel_options);




       /* harmony default export */ const Sidebar_PropertiesPanel = (PropertiesPanel/* default */.A && PropertiesPanel/* default */.A.locals ? PropertiesPanel/* default */.A.locals : undefined);

;// ./admin/js/src/components/Sidebar/PropertiesPanel.jsx








function PropertiesPanel_PropertiesPanel(_ref) {
  var elements = _ref.elements;
  var _useEditorStore = useEditorStore(),
    deleteSelectedElements = _useEditorStore.deleteSelectedElements,
    debugNumbersVisible = _useEditorStore.debugNumbersVisible,
    toggleDebugNumbersVisible = _useEditorStore.toggleDebugNumbersVisible;
  var allElements = useEditorStore(function (state) {
    return state.elements;
  });
  var handleDelete = function handleDelete() {
    deleteSelectedElements();
  };

  // Функция для перевода типа элемента на русский
  var getElementTypeLabel = function getElementTypeLabel(type) {
    var typeLabels = {
      'line': 'Линия',
      'arc': 'Дуга',
      'fillet': 'Скругление',
      'chamfer': 'Фаска'
    };
    return typeLabels[type] || type;
  };
  var lineElements = elements.filter(function (el) {
    return el.type === 'line';
  });
  var arcElements = elements.filter(function (el) {
    return el.type === 'arc';
  });
  var filletElements = elements.filter(function (el) {
    return el.type === 'fillet';
  });
  var chamferElements = elements.filter(function (el) {
    return el.type === 'chamfer';
  });
  var getElementLength = function getElementLength(element) {
    if (element.type === 'line') {
      if (element.start && element.end) {
        return distance(element.start, element.end);
      } else if (element.length) {
        return element.length;
      }
      return 0;
    }
    if (element.type === 'arc') {
      var radius = element.radius || 0;
      var angle = element.angle || 90;
      var angleRad = angle * Math.PI / 180;
      return radius * angleRad;
    }
    if (element.type === 'fillet') {
      // Для fillet используем данные из element.arc
      var _radius = element.arc && element.arc.radius || element.radius || 0;
      var _angle = element.arc && element.arc.angle || 0;
      var _angleRad = _angle * Math.PI / 180;
      return _radius * _angleRad;
    }
    if (element.type === 'chamfer') {
      // Для chamfer - это прямая линия, используем расстояние между точками
      if (element.start && element.end) {
        return distance(element.start, element.end);
      }
      return 0;
    }
    return 0;
  };

  // Вычисляем сводную информацию по всем элементам
  var allLines = allElements.filter(function (el) {
    return el.type === 'line';
  });
  var allFillets = allElements.filter(function (el) {
    return el.type === 'fillet';
  });
  var allChamfers = allElements.filter(function (el) {
    return el.type === 'chamfer';
  });
  var totalLinesLength = allLines.reduce(function (sum, line) {
    return sum + getElementLength(line);
  }, 0);
  var totalLinesLengthText = formatLengthMM(totalLinesLength);
  var filletsCount = allFillets.length;
  var chamfersCount = allChamfers.length;
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-properties-panel"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "panel-header"
  }, elements.length > 0 && /*#__PURE__*/external_React_default().createElement("button", {
    onClick: handleDelete,
    className: "delete-button"
  }, "\u0423\u0434\u0430\u043B\u0438\u0442\u044C")), /*#__PURE__*/external_React_default().createElement("div", {
    className: "panel-content"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "properties-summary"
  }, /*#__PURE__*/external_React_default().createElement("h4", null, "\u0421\u0432\u043E\u0434\u043A\u0430"), /*#__PURE__*/external_React_default().createElement("div", {
    className: "summary-item"
  }, /*#__PURE__*/external_React_default().createElement("span", {
    className: "summary-label"
  }, "\u041E\u0431\u0449\u0430\u044F \u0434\u043B\u0438\u043D\u0430 \u043B\u0438\u043D\u0438\u0439:"), /*#__PURE__*/external_React_default().createElement("span", {
    className: "summary-value"
  }, totalLinesLengthText)), /*#__PURE__*/external_React_default().createElement("div", {
    className: "summary-item"
  }, /*#__PURE__*/external_React_default().createElement("span", {
    className: "summary-label"
  }, "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u0439:"), /*#__PURE__*/external_React_default().createElement("span", {
    className: "summary-value"
  }, filletsCount)), /*#__PURE__*/external_React_default().createElement("div", {
    className: "summary-item"
  }, /*#__PURE__*/external_React_default().createElement("span", {
    className: "summary-label"
  }, "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u043A\u043E\u0441\u043E\u0432:"), /*#__PURE__*/external_React_default().createElement("span", {
    className: "summary-value"
  }, chamfersCount))), /*#__PURE__*/external_React_default().createElement("div", {
    className: "properties-summary"
  }, /*#__PURE__*/external_React_default().createElement("h4", null, elements.length === 0 ? 'Свойства' : "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 (".concat(elements.length, " \u0432\u044B\u0431\u0440\u0430\u043D\u043E)")), /*#__PURE__*/external_React_default().createElement("div", {
    className: "properties-elements-list"
  }, /*#__PURE__*/external_React_default().createElement("h4", {
    style: {
      marginTop: 0
    }
  }, "\u0412\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B:"), elements.length > 0 ? /*#__PURE__*/external_React_default().createElement("ul", {
    className: "properties-elements-list-items"
  }, elements.map(function (element, index) {
    var elementLength = getElementLength(element);
    var lengthText = formatLengthMM(elementLength);
    return /*#__PURE__*/external_React_default().createElement("li", {
      key: element.id,
      className: "properties-element-item"
    }, /*#__PURE__*/external_React_default().createElement("span", {
      className: "element-type-badge"
    }, getElementTypeLabel(element.type)), /*#__PURE__*/external_React_default().createElement("span", {
      className: "element-id"
    }, "#", index + 1), /*#__PURE__*/external_React_default().createElement("span", {
      className: "element-length"
    }, lengthText));
  })) : /*#__PURE__*/external_React_default().createElement("p", {
    className: "properties-empty-state"
  }, "\u042D\u043B\u0435\u043C\u0435\u043D\u0442\u044B \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D\u044B"))), lineElements.length > 0 && /*#__PURE__*/external_React_default().createElement(Sidebar_LineProperties, {
    elements: lineElements
  }), arcElements.length === 1 && /*#__PURE__*/external_React_default().createElement(Sidebar_ArcProperties, {
    element: arcElements[0]
  }), filletElements.length === 1 && /*#__PURE__*/external_React_default().createElement(Sidebar_FilletProperties, {
    element: filletElements[0]
  }), chamferElements.length === 1 && /*#__PURE__*/external_React_default().createElement(Sidebar_ChamferProperties, {
    element: chamferElements[0]
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "debug-controls",
    style: {
      marginTop: '20px',
      paddingTop: '20px',
      borderTop: '1px solid #ddd'
    }
  }, /*#__PURE__*/external_React_default().createElement("button", {
    type: "button",
    onClick: function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      toggleDebugNumbersVisible();
    },
    className: debugNumbersVisible ? 'active' : '',
    style: {
      width: '100%',
      padding: '10px',
      backgroundColor: debugNumbersVisible ? '#0073aa' : '#f0f0f0',
      color: debugNumbersVisible ? '#fff' : '#333',
      border: '1px solid #ccc',
      borderRadius: '4px',
      cursor: 'pointer',
      fontSize: '14px'
    },
    title: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C/\u0441\u043A\u0440\u044B\u0442\u044C \u043D\u043E\u043C\u0435\u0440\u0430 \u0442\u043E\u0447\u0435\u043A \u0434\u043B\u044F \u043E\u0442\u043B\u0430\u0434\u043A\u0438"
  }, debugNumbersVisible ? '✓ ' : '', "\u041E\u0442\u043B\u0430\u0434\u043E\u0447\u043D\u044B\u0435 \u043D\u043E\u043C\u0435\u0440\u0430"))));
}
/* harmony default export */ const components_Sidebar_PropertiesPanel = (PropertiesPanel_PropertiesPanel);
;// ./admin/js/src/utils/api.js
var _window$plintusEditor, _window$plintusEditor2;
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var API_BASE = ((_window$plintusEditor = window.plintusEditor) === null || _window$plintusEditor === void 0 ? void 0 : _window$plintusEditor.apiUrl) || '/wp-json/plintus-paperjs/v1/';
var NONCE = ((_window$plintusEditor2 = window.plintusEditor) === null || _window$plintusEditor2 === void 0 ? void 0 : _window$plintusEditor2.nonce) || '';
function loadProfileData(_x) {
  return _loadProfileData.apply(this, arguments);
}
function _loadProfileData() {
  _loadProfileData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(profileId) {
    var response, _t;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.p = _context.n) {
        case 0:
          _context.p = 0;
          _context.n = 1;
          return fetch("".concat(API_BASE, "profiles/").concat(profileId, "/data"), {
            method: 'GET',
            headers: {
              'X-WP-Nonce': NONCE
            }
          });
        case 1:
          response = _context.v;
          if (response.ok) {
            _context.n = 2;
            break;
          }
          throw new Error('Failed to load profile data');
        case 2:
          _context.n = 3;
          return response.json();
        case 3:
          return _context.a(2, _context.v);
        case 4:
          _context.p = 4;
          _t = _context.v;
          console.error('Error loading profile data:', _t);
          return _context.a(2, null);
      }
    }, _callee, null, [[0, 4]]);
  }));
  return _loadProfileData.apply(this, arguments);
}
function saveProfileData(_x2, _x3) {
  return _saveProfileData.apply(this, arguments);
}
function _saveProfileData() {
  _saveProfileData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(profileId, data) {
    var response, _t2;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.p = _context2.n) {
        case 0:
          _context2.p = 0;
          _context2.n = 1;
          return fetch("".concat(API_BASE, "profiles/").concat(profileId, "/data"), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-WP-Nonce': NONCE
            },
            body: JSON.stringify({
              data: data
            })
          });
        case 1:
          response = _context2.v;
          if (response.ok) {
            _context2.n = 2;
            break;
          }
          throw new Error('Failed to save profile data');
        case 2:
          _context2.n = 3;
          return response.json();
        case 3:
          return _context2.a(2, _context2.v);
        case 4:
          _context2.p = 4;
          _t2 = _context2.v;
          console.error('Error saving profile data:', _t2);
          return _context2.a(2, null);
      }
    }, _callee2, null, [[0, 4]]);
  }));
  return _saveProfileData.apply(this, arguments);
}
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./admin/js/src/App.css
var App = __webpack_require__(912);
;// ./admin/js/src/App.css

      
      
      
      
      
      
      
      
      

var App_options = {};

App_options.styleTagTransform = (styleTagTransform_default());
App_options.setAttributes = (setAttributesWithoutAttributes_default());

      App_options.insert = insertBySelector_default().bind(null, "head");
    
App_options.domAPI = (styleDomAPI_default());
App_options.insertStyleElement = (insertStyleElement_default());

var App_update = injectStylesIntoStyleTag_default()(App/* default */.A, App_options);




       /* harmony default export */ const src_App = (App/* default */.A && App/* default */.A.locals ? App/* default */.A.locals : undefined);

;// ./admin/js/src/App.jsx








function App_App() {
  var _window$plintusEditor;
  var _useEditorStore = useEditorStore(),
    selectedElements = _useEditorStore.selectedElements,
    loadProfile = _useEditorStore.loadProfile;
  var profileId = (_window$plintusEditor = window.plintusEditor) === null || _window$plintusEditor === void 0 ? void 0 : _window$plintusEditor.profileId;
  (0,external_React_.useEffect)(function () {
    // Загружаем данные профиля при монтировании
    if (profileId) {
      loadProfileData(profileId).then(function (response) {
        if (response && response.data) {
          loadProfile(response.data);
        }
      });
    }
  }, [profileId, loadProfile]);

  // Автосохранение через таймер
  (0,external_React_.useEffect)(function () {
    var interval = setInterval(function () {
      var _useEditorStore$getSt = useEditorStore.getState(),
        elements = _useEditorStore$getSt.elements,
        grid = _useEditorStore$getSt.grid,
        viewbox = _useEditorStore$getSt.viewbox;
      if (profileId && elements.length >= 0) {
        saveProfileData(profileId, {
          elements: elements,
          grid: grid,
          viewbox: viewbox
        });
      }
    }, 5000); // Сохраняем каждые 5 секунд

    return function () {
      return clearInterval(interval);
    };
  }, [profileId]);
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-editor"
  }, /*#__PURE__*/external_React_default().createElement(components_Toolbar_Toolbar, null), /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-editor-content"
  }, /*#__PURE__*/external_React_default().createElement(components_Toolbar_VerticalToolbar, null), /*#__PURE__*/external_React_default().createElement("div", {
    className: "plintus-editor-canvas-wrapper"
  }, /*#__PURE__*/external_React_default().createElement(components_Canvas_CanvasEditor, null)), /*#__PURE__*/external_React_default().createElement(components_Sidebar_PropertiesPanel, {
    elements: selectedElements
  })));
}
/* harmony default export */ const js_src_App = (App_App);
;// ./admin/js/src/index.js




// Инициализация для админки (старый контейнер)
var adminContainer = document.getElementById('plintus-profile-editor-paperjs-root');
if (adminContainer) {
  try {
    var root = client.createRoot(adminContainer);
    root.render(/*#__PURE__*/external_React_default().createElement(js_src_App, null));
  } catch (error) {
    console.error('Error rendering React app:', error);
  }
}

// Инициализация для фронтенда (шорткод)
function initFrontendEditor(containerId) {
  var container = document.getElementById(containerId);
  if (!container) {
    return;
  }

  // Получаем данные из window.plintusEditorInstances
  if (typeof window.plintusEditorInstances === 'undefined' || !window.plintusEditorInstances[containerId]) {
    return;
  }
  var editorData = window.plintusEditorInstances[containerId];

  // Устанавливаем глобальные данные для App компонента
  // Сохраняем оригинальные данные, если они есть
  var originalEditor = window.plintusEditor;
  window.plintusEditor = editorData;
  try {
    var _root = client.createRoot(container);
    _root.render(/*#__PURE__*/external_React_default().createElement(js_src_App, null));

    // Восстанавливаем оригинальные данные после рендеринга (если нужно)
    // Но на самом деле каждый компонент должен использовать свои данные
    // Поэтому оставляем последние установленные данные
  } catch (error) {
    console.error('Error rendering React app:', error);
    // Восстанавливаем оригинальные данные в случае ошибки
    if (originalEditor) {
      window.plintusEditor = originalEditor;
    }
  }
}

// Экспортируем функцию для вызова из inline скриптов
window.initPlintusEditor = initFrontendEditor;

// Инициализируем все редакторы на странице при загрузке
function initAllEditors() {
  if (typeof window.plintusEditorInstances === 'undefined') {
    return;
  }
  Object.keys(window.plintusEditorInstances).forEach(function (containerId) {
    var container = document.getElementById(containerId);
    if (container && !container.dataset.initialized) {
      container.dataset.initialized = 'true';
      initFrontendEditor(containerId);
    }
  });
}

// Инициализируем при загрузке DOM
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAllEditors);
} else {
  initAllEditors();
}
/******/ })()
;